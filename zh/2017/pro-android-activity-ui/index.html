<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/favicon.ico">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Professional Android笔记：Activity和UI - Brighton Zhang
        
    </title>

    <link rel="canonical" href="https://brightonzhang.com/zh/2017/pro-android-activity-ui/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <link rel="stylesheet" href="/css/jquery.fancybox.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/2017/1iTDUQIbX397042030.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header">
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#安卓" title="安卓">安卓</a>
                            
                        </div>
                        <h1>Professional Android笔记：Activity和UI</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted on 04/10/2017
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Brighton Zhang</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    <li>
                        <a href="/archive/">Archives</a>
                    </li>

                    <li>
                        <a href="/tags/">Tags</a>
                    </li>

                    <li>
                        <a href="/about/">About</a>
                    </li>

                    <!-- Brighton, 3/10/2018, hardcoded the navbar elements order -->  
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="activities">ACTIVITIES</h1>
<p><code>Activity</code> 是一个应用组件，用户可与其提供的屏幕进行交互，以执行某些操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。</p>
<p>一个应用通常由多个彼此松散联系的 Activity 组成。 一般会指定应用中的某个 Activity 为“主”Activity，即首次启动应用时呈现给用户的那个 Activity。 而且每个 Activity 均可启动另一个 Activity，以便执行不同的操作。 每次新 Activity 启动时，前一 Activity 便会停止，但系统会在堆栈（“返回栈”）中保留该 Activity。 当新 Activity 启动时，系统会将其推送到返回栈上，并取得用户焦点。 返回栈遵循基本的“后进先出”堆栈机制，因此，当用户完成当前 Activity 并按“返回”按钮时，系统会从堆栈中将其弹出（并销毁），然后恢复前一 Activity——可以参考文档<a href="https://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="noopener">任务和返回栈</a>。</p>
<p>当一个 Activity 因某个新 Activity 启动而停止时，系统会通过该 Activity 的生命周期回调方法通知其这一状态变化。Activity 因状态变化——系统是创建 Activity、停止 Activity、恢复 Activity 还是销毁 Activity——而收到的回调方法可能有若干种，每一种回调都会为您提供执行与该状态变化相应的特定操作的机会。 例如，停止时，您的 Activity 应释放任何大型对象，例如网络或数据库连接。 当 Activity 恢复时，您可以重新获取所需资源，并恢复执行中断的操作。 这些状态转变都是 Activity 生命周期的一部分。</p>
<h2 id="操作activity">操作Activity</h2>
<p>首先必须在清单文件中声明Activity，这样系统才能访问它：将 <code>activity</code> 元素添加为 <code>application</code> 元素的子项。<code>activity</code> 元素还可指定各种 Intent 过滤器——使用 <code>intent-filter</code> 元素——以声明其他应用组件激活它的方法。</p>
<p>要创建 Activity，必须创建 <code>Activity</code> 的子类（或使用其现有子类）。并需要在子类中实现 Activity 在其生命周期的各种状态之间转变时（例如创建 Activity、停止 Activity、恢复 Activity 或销毁 Activity 时）系统调用的回调方法。 两个最重要的回调方法是：<code>onCreate()</code>和<code>onPause()</code>。</p>
<p>Activity 的用户界面是由层级式视图——衍生自 <code>View</code> 类的对象——提供的。每个视图都控制 Activity 窗口内的特定矩形空间，可对用户交互作出响应。可以通过 <code>setContentView()</code> 将视图设置为 Activity 的 UI。</p>
<p>启动Activity的方法：</p>
<ul>
<li><code>startActivity()</code></li>
<li><code>startActivityForResult()</code>：当后续 Activity 完成时，会使用 Intent 向onActivityResult() 回调方法返回结果。</li>
</ul>
<p>结束Activity的方法：</p>
<ul>
<li><code>finish()</code></li>
<li><code>finishActivity()</code>： 结束之前启动的另一个Activity。</li>
</ul>
<p>在大多数情况下，不应使用这些方法显式结束 Activity——因为Android 系统会管理 Activity 的生命周期。</p>
<h2 id="activity-生命周期">Activity 生命周期</h2>
<p>Activity 存在以下状态：</p>
<ul>
<li>
<p>继续 resumed/active/running</p>
<p>此 Activity 位于屏幕前台并具有用户焦点。</p>
</li>
<li>
<p>暂停 paused</p>
<p>另一个 Activity 位于屏幕前台并具有用户焦点，但此 Activity 仍可见。也就是说，另一个 Activity 显示在此 Activity 上方，并且该 Activity 部分透明或未覆盖整个屏幕。 暂停的 Activity 处于完全活动状态（<code>Activity</code> 对象保留在内存中，它保留了所有状态和成员信息，并与窗口管理器保持连接），但在内存极度不足的情况下，可能会被系统终止。</p>
</li>
<li>
<p>停止 stopped</p>
<p>该 Activity 被另一个 Activity 完全遮盖（该 Activity 目前位于“后台”）。 已停止的 Activity 同样仍处于活动状态（<code>Activity</code> 对象保留在内存中，它保留了所有状态和成员信息，但未与窗口管理器连接）。 不过，它对用户不再可见，在他处需要内存时可能会被系统终止。</p>
</li>
<li>
<p>Inactive</p>
<p>After an Activity has been killed, as well as before it’s been launched, it’s inactive. Inactive Activities have been removed from the Activity stack and need to be restarted before they can be displayed and used.</p>
</li>
</ul>
<h3 id="生命周期回调">生命周期回调</h3>
<p>当一个 Activity 转入和转出上述不同状态时，系统会通过各种回调方法向其发出通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// The activity is being created.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">// The activity is about to become visible.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="comment">// The activity has become visible (it is now "resumed").</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        <span class="comment">// Another activity is taking focus (this activity is about to be "paused").</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="comment">// The activity is no longer visible (it is now "stopped")</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// The activity is about to be destroyed.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法共同定义 Activity 的整个生命周期。通过实现这些方法来监控 Activity 生命周期中的三个嵌套循环：</p>
<ul>
<li>Activity 的<strong>整个生命周期</strong>发生在 <code>onCreate()</code> 调用与 <code>onDestroy()</code> 调用之间。Activity 应在 <code>onCreate()</code> 中执行“全局”状态设置（例如定义布局），并在 <code>onDestroy()</code> 中释放所有资源。例如，如果 Activity 有一个在后台运行的线程，用于从网络上下载数据，它可能会在 <code>onCreate()</code> 中创建该线程，然后在 <code>onDestroy()</code> 中停止该线程。</li>
<li>Activity 的<strong>可见生命周期</strong>发生在 <code>onStart()</code> 调用与 <code>onStop()</code> 调用之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。 例如，当一个新 Activity 启动，并且此 Activity 不再可见时，系统会调用 <code>onStop()</code>。您可以在调用这两个方法之间保留向用户显示 Activity 所需的资源。 例如，您可以在 <code>onStart()</code> 中注册一个 <code>BroadcastReceiver</code> 以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 <code>onStop()</code> 中将其取消注册。在 Activity 的整个生命周期，当 Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用 <code>onStart()</code> 和 <code>onStop()</code>。</li>
<li>Activity 的<strong>前台生命周期</strong>发生在 <code>onResume()</code> 调用与 <code>onPause()</code> 调用之间。在这段时间，Activity 位于屏幕上的所有其他 Activity 之前，并具有用户输入焦点。 Activity 可频繁转入和转出前台——例如，当设备转入休眠状态或出现对话框时，系统会调用 <code>onPause()</code>。 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。</li>
</ul>
<p>下图说明了这些循环以及 Activity 在状态转变期间可能经过的路径。矩形表示回调方法，当 Activity 在不同状态之间转变时，可以实现这些方法来执行操作。</p>
<img src="https://developer.android.com/images/activity_lifecycle.png" alt="Activity 生命周期">
<h3 id="保存-activity-状态">保存 Activity 状态</h3>
<p>当 Activity 暂停或停止时，<code>Activity</code> 对象仍保留在内存中——有关其成员和当前状态的所有信息仍处于活动状态。 用户在 Activity 内所做的任何更改都会得到保留，这样一来，当 Activity 返回前台（当它“继续”）时，这些更改仍然存在。</p>
<p>不过，当系统为了恢复内存而销毁某项 Activity 时，<code>Activity</code> 对象也会被销毁，因此系统在继续 Activity 时根本无法让其状态保持完好，而是必须在用户返回 Activity 时重建 <code>Activity</code> 对象。 在这种情况下，可以实现另一个回调方法对有关 Activity 状态的信息进行保存，以确保有关 Activity 状态的重要信息得到保留：<code>onSaveInstanceState()</code>。</p>
<p>系统会先调用 <code>onSaveInstanceState()</code>，然后再使 Activity 变得易于销毁。系统会向该方法传递一个 <code>Bundle</code>，可以在其中使用 <code>putString()</code> 和 <code>putInt()</code> 等方法以“名称-值”对形式保存有关 Activity 状态的信息。然后，如果系统终止您的应用进程，并且用户返回您的 Activity，则系统会重建该 Activity，并将 <code>Bundle</code> 同时传递给 <code>onCreate()</code> 和 <code>onRestoreInstanceState()</code>。您可以使用上述任一方法从 <code>Bundle</code> 提取您保存的状态并恢复该 Activity 状态。如果没有状态信息需要恢复，则传递给您的 <code>Bundle</code> 是空值（如果是首次创建该 Activity，就会出现这种情况）。</p>
<img src="https://developer.android.com/images/fundamentals/restore_instance.png" alt="">
<p>有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。 发生此类变化时，Android 会重建运行中的 Activity（系统调用 <code>onDestroy()</code>，然后立即调用 <code>onCreate()</code>）。处理此类重启的最佳方法是利用<code>onSaveInstanceState()</code> 和 <code>onRestoreInstanceState()</code>（或 <code>onCreate()</code>）保存并恢复 Activity 的状态。</p>
<h3 id="协调-activity">协调 Activity</h3>
<p>当一个 Activity 启动另一个 Activity 时，它们都会体验到生命周期转变。启动第二个 Activity 的过程与停止第一个 Activity 的过程存在重叠。Android中activity生命周期回调的顺序经过明确定义，当两个 Activity 位于同一进程，并且由一个 Activity 启动另一个 Activity 时，其定义尤其明确。 以下是当 Activity A 启动 Activity B 时一系列操作的发生顺序：</p>
<ol>
<li>Activity A 的 <code>onPause()</code> 方法执行。</li>
<li>Activity B 的 <code>onCreate()</code>、<code>onStart()</code> 和 <code>onResume()</code> 方法依次执行。（Activity B 现在具有用户焦点。）</li>
<li>然后，如果 Activity A 在屏幕上不再可见，则其 <code>onStop()</code> 方法执行。</li>
</ol>
<h3 id="responding-to-memory-pressure">Responding to Memory Pressure</h3>
<p>You can help by overriding the <code>onTrimMemory</code> handler, to respond to system requests that you reduce your memory usage.</p>
<h1 id="fragments">FRAGMENTS</h1>
<p><code>Fragment</code> 表示 <code>Activity</code> 中的行为或用户界面部分。可以将多个Fragments组合在一个 Activity 中来构建多窗格 UI，以及在多个 Activity 中重复使用某个Fragment。可以将Fragments视为 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，并且可以在 Activity 运行时添加或移除Fragments（有点像可以在不同 Activity 中重复使用的“子 Activity”）。</p>
<p>Fragments enable you to divide your Activities into fully encapsulated reusable components, each with its own life cycle and state.</p>
<p>Fragments必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。 例如，当 Activity 暂停时，其中的所有Fragments也会暂停；当 Activity 被销毁时，所有Fragments也会被销毁。 不过，当 Activity 正在运行时，可以独立操纵每个Fragment，如添加或移除它们。当执行此类Fragment事务(transaction)时，也可以将其添加到由 Activity 管理的返回栈——Activity 中的每个返回栈条目都是一条已发生Fragment事务的记录。 返回栈让用户可以通过按返回按钮撤消Fragment事务（后退）。</p>
<p>当Fragment作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 <code>ViewGroup</code> 内部，并且Fragment会定义其自己的视图布局。可以通过在 Activity 的布局文件中声明Fragment，将其作为 <code>&lt;fragment&gt;</code> 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 <code>ViewGroup</code>，利用应用代码进行插入。不过，Fragment并非必须成为 Activity 布局的一部分；还可以将没有自己 UI 的Fragment用作 Activity 的不可见工作线程。</p>
<h2 id="创建fragment">创建Fragment</h2>
<p>要想创建Fragment，必须创建 <code>Fragment</code> 的子类（或已有其子类）。<code>Fragment</code> 类的代码与 <code>Activity</code> 非常相似。它包含与 Activity 类似的回调方法，如 <code>onCreate()</code>、<code>onStart()</code>、<code>onPause()</code> 和 <code>onStop()</code>。通常，至少应实现以下生命周期方法：</p>
<ul>
<li>
<p><code>onCreate()</code></p>
<p>系统会在创建Fragment时调用此方法。您应该在实现内初始化您想在Fragment暂停或停止后恢复时保留的必需Fragment组件。</p>
</li>
<li>
<p><code>onCreateView()</code></p>
<p>系统会在Fragment首次绘制其用户界面时调用此方法。 要想为您的Fragment绘制 UI，您从此方法中返回的 <code>View</code> 必须是Fragment布局的根视图。如果Fragment未提供 UI，您可以返回 null。</p>
</li>
<li>
<p><code>onPause()</code></p>
<p>系统将此方法作为用户离开Fragment的第一个信号（但并不总是意味着此Fragment会被销毁）进行调用。 您通常应该在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。</p>
</li>
</ul>
<h3 id="添加用户界面">添加用户界面</h3>
<p>Fragment通常用作 Activity 用户界面的一部分，将其自己的布局融入 Activity。</p>
<p>要想为Fragment提供布局，必须实现 <code>onCreateView()</code> 回调方法，Android 系统会在Fragment需要绘制其布局时调用该方法。对此方法的实现返回的 <code>View</code> 必须是Fragment布局的根视图。要想从 <code>onCreateView()</code> 返回布局，可以通过 XML 中定义的布局资源来扩展布局。为帮助执行此操作，<code>onCreateView()</code> 提供了一个 <code>LayoutInflater</code> 对象。</p>
<p>例如，以下这个 <code>Fragment</code> 子类从 <code>example_fragment.xml</code> 文件加载布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the layout for this fragment</span></span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.example_fragment, container, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递至 <code>onCreateView()</code> 的 <code>container</code> 参数是Fragment布局将插入到的父 <code>ViewGroup</code>（来自 Activity 的布局）。<code>savedInstanceState</code> 参数是在恢复Fragment时，提供上一Fragment实例相关数据的 <code>Bundle</code>。</p>
<p><code>inflate()</code> 方法带有三个参数：</p>
<ul>
<li>想要扩展的布局的资源 ID；</li>
<li>将作为扩展布局父项的 <code>ViewGroup</code>。传递 <code>container</code> 对系统向扩展布局的根视图（由其所属的父视图指定）应用布局参数具有重要意义；</li>
<li>指示是否应该在扩展期间将扩展布局附加至 <code>ViewGroup</code>（第二个参数）的布尔值。（在本例中，其值为 false，因为系统已经将扩展布局插入 <code>container</code> — 传递 true 值会在最终布局中创建一个多余的视图组。）</li>
</ul>
<h3 id="向-activity-添加fragment">向 Activity 添加Fragment</h3>
<p>通常，Fragment向宿主 Activity 贡献一部分 UI，作为 Activity 总体视图层次结构的一部分嵌入到 Activity 中。可以通过两种方式向 Activity 布局添加Fragment：</p>
<ul>
<li>
<p>在 Activity 的布局文件内声明Fragment</p>
<p>在本例中，您可以将Fragment当作视图来为其指定布局属性。 例如，以下是一个具有两个Fragment的 Activity 的布局文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">"com.example.news.ArticleListFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/list"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">"com.example.news.ArticleReaderFragment"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/viewer"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;fragment&gt;</code> 中的 <code>android:name</code> 属性指定要在布局中实例化的 <code>Fragment</code> 类。</p>
<p>当系统创建此 Activity 布局时，会实例化在布局中指定的每个Fragment，并为每个Fragment调用 <code>onCreateView()</code> 方法，以检索每个Fragment的布局。系统会直接插入Fragment返回的 <code>View</code> 来替代 <code>&lt;fragment&gt;</code> 元素。</p>
<p><strong>注</strong>：每个Fragment都需要一个唯一的标识符，重启 Activity 时，系统可以使用该标识符来恢复Fragment（您也可以使用该标识符来捕获Fragment以执行某些事务，如将其移除）。 可以通过三种方式为Fragment提供 ID：</p>
<ul>
<li>为 <code>android:id</code> 属性提供唯一 ID。</li>
<li>为 <code>android:tag</code> 属性提供唯一字符串。</li>
<li>如果您未给以上两个属性提供值，系统会使用容器视图的 ID。</li>
</ul>
</li>
<li>
<p>或者通过编程方式将Fragment添加到某个现有 <code>ViewGroup</code></p>
<p>可以在 Activity 运行期间随时将Fragment添加到 Activity 布局中——只需指定要将Fragment放入哪个 <code>ViewGroup</code>。</p>
<p>要想在 Activity 中执行Fragment事务（如添加、移除或替换Fragment），必须使用 <code>FragmentTransaction</code> 中的 API。可以像下面这样从 <code>Activity</code> 获取一个 <code>FragmentTransaction</code> 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FragmentManager fragmentManager = getFragmentManager();</span><br><span class="line">FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span><br></pre></td></tr></table></figure>
<p>然后，可以使用 <code>add()</code> 方法添加一个Fragment，指定要添加的Fragment以及将其插入哪个视图。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExampleFragment fragment = new ExampleFragment();</span><br><span class="line">fragmentTransaction.add(R.id.fragment_container, fragment);</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure>
<p>传递到 <code>add()</code> 的第一个参数是 <code>ViewGroup</code>，即应该放置Fragment的位置，由资源 ID 指定，第二个参数是要添加的Fragment。</p>
<p>一旦通过 <code>FragmentTransaction</code> 做出了更改，就必须调用 <code>commit()</code> 以使更改生效。</p>
</li>
</ul>
<h3 id="添加没有-ui-的fragment">添加没有 UI 的Fragment</h3>
<p>还可以使用Fragment为 Activity 提供后台行为，而不显示额外 UI。要想添加没有 UI 的Fragment，请使用 <code>add(Fragment, String)</code> 从 Activity 添加Fragment（为Fragment提供一个唯一的字符串“标记”，而不是视图 ID）。 这会添加Fragment，但由于它并不与 Activity 布局中的视图关联，因此不会收到对 <code>onCreateView()</code> 的调用。因此，您不需要实现该方法。</p>
<p>并非只能为非 UI Fragment提供字符串标记——也可以为具有 UI 的Fragment提供字符串标记——但如果Fragment没有 UI，则字符串标记将是标识它的唯一方式。如果您想稍后从 Activity 中获取Fragment，则需要使用 <code>findFragmentByTag()</code>。</p>
<h2 id="管理fragment">管理Fragment</h2>
<p>要想管理 Activity 中的Fragment，需要使用 <code>FragmentManager</code>——从 Activity 调用<code>getFragmentManager()</code>获取。可以使用 <code>FragmentManager</code> 执行的操作包括：</p>
<ul>
<li>通过 <code>findFragmentById()</code>（对于在 Activity 布局中提供 UI 的Fragment）或 <code>findFragmentByTag()</code>（对于提供或不提供 UI 的Fragment）获取 Activity 中存在的Fragment。</li>
<li>通过 <code>popBackStack()</code>（模拟用户发出的返回命令）将Fragment从返回栈中弹出。</li>
<li>通过 <code>addOnBackStackChangedListener()</code> 注册一个侦听返回栈变化的侦听器。</li>
</ul>
<p>也可以使用 <code>FragmentManager</code> 打开一个 <code>FragmentTransaction</code>，通过它来执行某些事务，如添加和移除Fragment。</p>
<h2 id="执行fragment事务">执行Fragment事务</h2>
<p>在 Activity 中使用Fragment的一大优点是，可以根据用户行为通过它们执行添加、移除、替换以及其他操作。 提交给 Activity 的每组更改都称为事务，您可以使用 <code>FragmentTransaction</code> 中的 API 来执行一项事务。也可以将每个事务保存到由 Activity 管理的返回栈内，从而让用户能够回退Fragment更改（类似于回退 Activity）。</p>
<p>像下面这样从 <code>FragmentManager</code> 获取一个 <code>FragmentTransaction</code> 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FragmentManager fragmentManager = getFragmentManager();</span><br><span class="line">FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span><br></pre></td></tr></table></figure>
<p>每个事务都是您想要同时执行的一组更改。您可以使用 <code>add()</code>、<code>remove()</code> 和 <code>replace()</code> 等方法为给定事务设置您想要执行的所有更改。然后，要想将事务应用到 Activity，您必须调用 <code>commit()</code>。</p>
<p>不过，在您调用 <code>commit()</code> 之前，您可能想调用 <code>addToBackStack()</code>，以将事务添加到Fragment事务返回栈。 该返回栈由 Activity 管理，允许用户通过按返回按钮返回上一Fragment状态。</p>
<p>例如，以下示例说明了如何将一个Fragment替换成另一个Fragment，以及如何在返回栈中保留先前状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create new fragment and transaction</span></span><br><span class="line">Fragment newFragment = <span class="keyword">new</span> ExampleFragment();</span><br><span class="line">FragmentTransaction transaction = getFragmentManager().beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace whatever is in the fragment_container view with this fragment,</span></span><br><span class="line"><span class="comment">// and add the transaction to the back stack</span></span><br><span class="line">transaction.replace(R.id.fragment_container, newFragment);</span><br><span class="line">transaction.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction</span></span><br><span class="line">transaction.commit();</span><br></pre></td></tr></table></figure>
<p>在上例中，<code>newFragment</code> 会替换目前在 <code>R.id.fragment_container</code> ID 所标识的布局容器中的任何Fragment（如有）。通过调用 <code>addToBackStack()</code> 可将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一Fragment。</p>
<p>如果您向事务添加了多个更改（如又一个 <code>add()</code> 或 <code>remove()</code>），并且调用了 <code>addToBackStack()</code>，则在调用<code>commit()</code> 前应用的所有更改都将作为单一事务添加到返回栈，并且返回按钮会将它们一并撤消。</p>
<p>向 <code>FragmentTransaction</code> 添加更改的顺序无关紧要，不过：</p>
<ul>
<li>您必须最后调用 <code>commit()</code></li>
<li>如果您要向同一容器添加多个Fragment，则您添加Fragment的顺序将决定它们在视图层次结构中的出现顺序</li>
</ul>
<p>如果您没有在执行移除Fragment的事务时调用 <code>addToBackStack()</code>，则事务提交时该Fragment会被销毁，用户将无法回退到该Fragment。 不过，如果您在删除Fragment时调用了 <code>addToBackStack()</code>，则系统会<em>停止</em>该Fragment，并在用户回退时将其恢复。</p>
<p>对于每个Fragment事务，您都可以通过在提交前调用 <code>setTransition()</code> 来应用过渡动画。</p>
<p>调用 <code>commit()</code> 不会立即执行事务，而是在 Activity 的 UI 线程（“主”线程）可以执行该操作时再安排其在线程上运行。不过，如有必要，您也可以从 UI 线程调用 <code>executePendingTransactions()</code> 以立即执行 <code>commit()</code> 提交的事务。通常不必这样做，除非其他线程中的作业依赖该事务。</p>
<p>只能在 Activity 保存其状态（用户离开 Activity）之前使用 <code>commit()</code> 提交事务。如果您试图在该时间点后提交，则会引发异常。 这是因为如需恢复 Activity，则提交后的状态可能会丢失。 对于丢失提交无关紧要的情况，请使用 <code>commitAllowingStateLoss()</code>。</p>
<h2 id="与-activity-通信">与 Activity 通信</h2>
<p>尽管 <code>Fragment</code> 是作为独立于 <code>Activity</code> 的对象实现，并且可在多个 Activity 内使用，但Fragment的给定实例会直接绑定到包含它的 Activity。具体地说，Fragment可以通过 <code>getActivity()</code> 访问 <code>Activity</code> 实例，并轻松地执行在 Activity 布局中查找视图等任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View listView = getActivity().findViewById(R.id.list);</span><br></pre></td></tr></table></figure>
<p>同样地，您的 Activity 也可以使用 <code>findFragmentById()</code> 或 <code>findFragmentByTag()</code>，通过从 <code>FragmentManager</code> 获取对 <code>Fragment</code> 的引用来调用Fragment中的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</span><br></pre></td></tr></table></figure>
<h3 id="创建对-activity-的事件回调">创建对 Activity 的事件回调</h3>
<p>在某些情况下，可能需要通过Fragment与 Activity 共享事件。执行此操作的一个好方法是，在Fragment内定义一个回调接口，并要求宿主 Activity 实现它。 当 Activity 通过该接口收到回调时，可以根据需要与布局中的其他Fragment共享这些信息。</p>
<p>例如，如果一个新闻应用的 Activity 有两个Fragment — 一个用于显示文章列表（Fragment A），另一个用于显示文章（Fragment B）— 那么Fragment A 必须在列表项被选定后告知 Activity，以便它告知Fragment B 显示该文章。 在本例中，<code>OnArticleSelectedListener</code> 接口在Fragment A 内声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static class FragmentA extends ListFragment &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Container Activity must implement this interface</span><br><span class="line">    public interface OnArticleSelectedListener &#123;</span><br><span class="line">        public void onArticleSelected(Uri articleUri);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，该Fragment的宿主 Activity 会实现 <code>OnArticleSelectedListener</code> 接口并替代 <code>onArticleSelected()</code>，将来自Fragment A 的事件通知Fragment B。为确保宿主 Activity 实现此接口，Fragment A 的 <code>onAttach()</code> 回调方法（系统在向 Activity 添加Fragment时调用的方法）会通过转换传递到 <code>onAttach()</code> 中的 <code>Activity</code> 来实例化 <code>OnArticleSelectedListener</code> 的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static class FragmentA extends ListFragment &#123;</span><br><span class="line">    OnArticleSelectedListener mListener;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public void onAttach(Activity activity) &#123;</span><br><span class="line">        super.onAttach(activity);</span><br><span class="line">        try &#123;</span><br><span class="line">            mListener = (OnArticleSelectedListener) activity;</span><br><span class="line">        &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            throw new ClassCastException(activity.toString() + &quot; must implement OnArticleSelectedListener&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Activity 未实现接口，则Fragment会引发 <code>ClassCastException</code>。实现时，<code>mListener</code> 成员会保留对 Activity 的 <code>OnArticleSelectedListener</code> 实现的引用，以便Fragment A 可以通过调用 <code>OnArticleSelectedListener</code> 接口定义的方法与 Activity 共享事件。例如，如果Fragment A 是 <code>ListFragment</code> 的一个扩展，则用户每次点击列表项时，系统都会调用Fragment中的 <code>onListItemClick()</code>，然后该方法会调用 <code>onArticleSelected()</code> 以与 Activity 共享事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static class FragmentA extends ListFragment &#123;</span><br><span class="line">    OnArticleSelectedListener mListener;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">        // Append the clicked item&apos;s row ID with the content provider Uri</span><br><span class="line">        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);</span><br><span class="line">        // Send the event and Uri to the host activity</span><br><span class="line">        mListener.onArticleSelected(noteUri);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递到 <code>onListItemClick()</code> 的 <code>id</code> 参数是被点击项的行 ID，即 Activity（或其他Fragment）用来从应用的 <code>ContentProvider</code> 获取文章的 ID。</p>
<h2 id="处理fragment生命周期">处理Fragment生命周期</h2>
<p>管理Fragment生命周期与管理 Activity 生命周期很相似。和 Activity 一样，Fragment也以三种状态存在：</p>
<ul>
<li>继续：Fragment在运行中的 Activity 中可见。</li>
<li>暂停：另一个 Activity 位于前台并具有焦点，但此Fragment所在的 Activity 仍然可见（前台 Activity 部分透明，或未覆盖整个屏幕）。</li>
<li>停止：Fragment不可见。宿主 Activity 已停止，或Fragment已从 Activity 中移除，但已添加到返回栈。 停止Fragment仍然处于活动状态（系统会保留所有状态和成员信息）。 不过，它对用户不再可见，如果 Activity 被终止，它也会被终止。</li>
</ul>
<p>同样与 Activity 一样，假使 Activity 的进程被终止，而您需要在重建 Activity 时恢复Fragment状态，您也可以使用 <code>Bundle</code> 保留Fragment的状态。您可以在Fragment的 <code>onSaveInstanceState()</code> 回调期间保存状态，并可在 <code>onCreate()</code>、<code>onCreateView()</code> 或 <code>onActivityCreated()</code> 期间恢复状态。</p>
<p>Activity 生命周期与Fragment生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。 默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈（以便用户通过返回按钮回退到 Activity）。不过，仅当在移除Fragment的事务执行期间通过调用 <code>addToBackStack()</code> 显式请求保存实例时，系统才会将Fragment放入由宿主 Activity 管理的返回栈。</p>
<p>在其他方面，管理Fragment生命周期与管理 Activity 生命周期非常相似。 因此，管理 Activity 生命周期的做法同样适用于Fragment。 但还需要了解 Activity 的生命周期对Fragment生命周期的影响。</p>
<h3 id="与-activity-生命周期协调一致">与 Activity 生命周期协调一致</h3>
<p>Fragment所在的 Activity 的生命周期会直接影响Fragment的生命周期，其表现为，Activity 的每次生命周期回调都会引发每个Fragment的类似回调。 例如，当 Activity 收到 <code>onPause()</code> 时，Activity 中的每个Fragment也会收到 <code>onPause()</code>。</p>
<p>不过，Fragment还有几个额外的生命周期回调，用于处理与 Activity 的唯一交互，以执行构建和销毁Fragment UI 等操作。 这些额外的回调方法是：</p>
<ul>
<li>
<p><code>onAttach()</code></p>
<p>在Fragment已与 Activity 关联时调用（<code>Activity</code> 传递到此方法内）。</p>
</li>
<li>
<p><code>onCreateView()</code></p>
<p>调用它可创建与Fragment关联的视图层次结构。</p>
</li>
<li>
<p><code>onActivityCreated()</code></p>
<p>在 Activity 的 <code>onCreate()</code> 方法已返回时调用。</p>
</li>
<li>
<p><code>onDestroyView()</code></p>
<p>在移除与Fragment关联的视图层次结构时调用。</p>
</li>
<li>
<p><code>onDetach()</code></p>
<p>在取消Fragment与 Activity 的关联时调用。</p>
</li>
</ul>
<p>只有当 Activity 处于恢复状态时，Fragment的生命周期才能独立变化。</p>
<h1 id="ui">UI</h1>
<p>Activity 的用户界面是由层级式视图——衍生自 <code>View</code> 类的对象——提供的。每个视图都控制 Activity 窗口内的特定矩形空间，可对用户交互作出响应。Android 提供了许多现成视图以便设计和组织布局。“小部件widgets”是提供按钮、文本字段、复选框或仅仅是一幅图像等屏幕视觉（交互式）元素的视图。 “布局layouts”是衍生自 <code>ViewGroup</code> 的视图，为其子视图提供唯一布局模型，例如线性布局、网格布局或相对布局。利用视图定义布局的最常见方法是借助保存在应用资源内的 XML 布局文件。这样可以将用户界面的设计与定义 Activity 行为的源代码分开维护。 可以通过 <code>setContentView()</code> 将布局设置为 Activity 的 UI，从而传递布局的资源 ID。也可以在 Activity 代码中创建新 <code>View</code>，并通过将新 <code>View</code> 插入 <code>ViewGroup</code> 来创建视图层次，然后通过将根 <code>ViewGroup</code> 传递到 <code>setContentView()</code> 来使用该布局。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateChangeMonitoringActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Called at the start of the full lifetime.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize Activity and inflate the UI.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called before subsequent visible lifetimes</span></span><br><span class="line">    <span class="comment">// for an Activity process. That is, before an Activity</span></span><br><span class="line">    <span class="comment">// returns to being visible having previously been hidden.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">        <span class="comment">// Load changes knowing that the Activity has already</span></span><br><span class="line">        <span class="comment">// been visible within this process.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called at the start of the visible lifetime.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">// Apply any required UI change now that the Activity is visible.</span></span><br><span class="line">        <span class="comment">// This is where you'd typically start any processes that</span></span><br><span class="line">        <span class="comment">// are required to ensure your UI is appropriately populated and</span></span><br><span class="line">        <span class="comment">// updated.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called after onStart has finished, in cases where an Activity is</span></span><br><span class="line">    <span class="comment">// started after having last been destroyed by the runtime rather than</span></span><br><span class="line">    <span class="comment">// through user or programmatic action (such as the user hitting back or</span></span><br><span class="line">    <span class="comment">// your app calling finish().</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Restore UI state from the savedInstanceState.</span></span><br><span class="line">        <span class="comment">// This bundle has also been passed to onCreate.</span></span><br><span class="line">        <span class="comment">// Will only be called if the Activity has been</span></span><br><span class="line">        <span class="comment">// killed by the system since it was last visible.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called at the start of the active lifetime.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Resume any paused UI updates, threads, or processes required</span></span><br><span class="line">        <span class="comment">// by the Activity but suspended when it becomes inactive.</span></span><br><span class="line">        <span class="comment">// At this stage, your Activity is active and receiving input</span></span><br><span class="line">        <span class="comment">// from users actions.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called at the end of the active lifetime.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Suspend UI updates, threads, or CPU intensive processes</span></span><br><span class="line">        <span class="comment">// that don't need to be updated when the Activity isn't</span></span><br><span class="line">        <span class="comment">// the active foreground Activity. Note that in multi-screen</span></span><br><span class="line">        <span class="comment">// mode, paused Activities may still be visible, and as such</span></span><br><span class="line">        <span class="comment">// should continue performing required UI updates.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when appropriate to save UI state changes at the</span></span><br><span class="line">    <span class="comment">// end of the active lifecycle.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save UI state changes to the savedInstanceState.</span></span><br><span class="line">        <span class="comment">// This bundle will be passed to onCreate and</span></span><br><span class="line">        <span class="comment">// onRestoreInstanceState if the process is</span></span><br><span class="line">        <span class="comment">// killed and restarted by the run time. Note that</span></span><br><span class="line">        <span class="comment">// this handler may not be called if the runtime determines</span></span><br><span class="line">        <span class="comment">// that the Activity is being "permanently" terminated.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called at the end of the visible lifetime.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Suspend remaining UI updates, threads, or processing</span></span><br><span class="line">        <span class="comment">// that aren't required when the Activity isn't visible.</span></span><br><span class="line">        <span class="comment">// Persist all edits or state changes as your Activity</span></span><br><span class="line">        <span class="comment">// may be killed at any time after onStop has</span></span><br><span class="line">        <span class="comment">// completed.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sometimes called at the end of the full lifetime.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clean up any resources including ending threads,</span></span><br><span class="line">        <span class="comment">// closing database connections etc.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/zh/2017/pro-android-gradle/" data-toggle="tooltip" data-placement="top" title="Professional Android笔记：GRADLE构建">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/zh/2017/java-packages/" data-toggle="tooltip" data-placement="top" title="Java Packages 包">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#activities"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">ACTIVITIES</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#操作activity"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">操作Activity</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#activity-生命周期"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">Activity 生命周期</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#生命周期回调"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">生命周期回调</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#保存-activity-状态"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">保存 Activity 状态</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#协调-activity"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">协调 Activity</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#responding-to-memory-pressure"><span class="toc-nav-number">1.2.4.</span> <span class="toc-nav-text">Responding to Memory Pressure</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#fragments"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">FRAGMENTS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#创建fragment"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">创建Fragment</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#添加用户界面"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">添加用户界面</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#向-activity-添加fragment"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">向 Activity 添加Fragment</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#添加没有-ui-的fragment"><span class="toc-nav-number">2.1.3.</span> <span class="toc-nav-text">添加没有 UI 的Fragment</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#管理fragment"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">管理Fragment</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#执行fragment事务"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">执行Fragment事务</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#与-activity-通信"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">与 Activity 通信</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#创建对-activity-的事件回调"><span class="toc-nav-number">2.4.1.</span> <span class="toc-nav-text">创建对 Activity 的事件回调</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#处理fragment生命周期"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">处理Fragment生命周期</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#与-activity-生命周期协调一致"><span class="toc-nav-number">2.5.1.</span> <span class="toc-nav-text">与 Activity 生命周期协调一致</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#ui"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">UI</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#安卓" title="安卓">安卓</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>




<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "brightonzhang-com";
    var disqus_identifier = "https://brightonzhang.com/zh/2017/pro-android-activity-ui/";
    var disqus_url = "https://brightonzhang.com/zh/2017/pro-android-activity-ui/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/brightonzhang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                

                

                

                
                    <li>
                        <a target="_blank" href="https://github.com/brightonzhang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Brighton Zhang 2019 
                    <br>
                    Powered by <a href="https://hexo.io/">Hexo</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Theme from <a href="https://huangxuan.me">Hux</a>, <a href="http://beantech.org">BeanTech</a> and <a href="https://brightonzhang.com">Brighton</a>  
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<script src="/js/jquery.fancybox.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://brightonzhang.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-114837917-1';
    var _gaDomain = 'auto';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://brightonzhang.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
