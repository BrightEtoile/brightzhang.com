<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Brighton Zhang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Brighton Zhang">
<meta property="og:url" content="http://brightonzhang.com/index.html">
<meta property="og:site_name" content="Brighton Zhang">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Brighton Zhang">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Brighton Zhang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Brighton Zhang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">We can burn brighter than the sun</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://brightonzhang.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-bitcoin-explained-with-emoji-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/bitcoin-explained-with-emoji-2/" class="article-date">
  <time datetime="2017-08-20T08:07:11.000Z" itemprop="datePublished">08-20-2017</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/bitcoin-explained-with-emoji-2/">比特币的另类解释之表情包·中篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文翻译至<a href="https://twitter.com/_tessr" target="_blank" rel="external">Tess Rinearson</a>的<a href="https://medium.com/@tessr/making-money-trustworthy-6c552a1cfc25" target="_blank" rel="external">Making Money Bitcoin Explained (with Emoji), Part 2</a>，该翻译和发布已获得原作者允许。由于本人能力和时间有限，翻译如有纰漏或不妥，还请见谅。若对内容和翻译有任何建议或意见，欢迎交流。</p>
<hr>
<p><em>在<a href="http://brightonzhang.com/2017/07/bitcoin-explained-with-emoji-1/">第一章</a>，我们了解到了比特币是一种去中心化的货币，不由任何政府和金融财团发行和管理。另外，我们讲述了哈希的基本概念。现在我们一起来看看比特币矿工是如何利用哈希来赚钱的，以及比特币如何利用密码学来保证其被信任，唯一和不被复制，还可以完全且不可逆的转账。</em></p>
<hr>
<p>比特币，像美元一样，价值波动。即使价值波动，人们依旧相信货币。<br>当美元有黄金保障时，人们相信美元因为它可以换真金白银。现在人们相信美元因为相信美国政府，也相信政府保障的银行。<br>比特币生来值得被高度信任，并不是因为背后有黄金或政府，而是依赖数学，确切的说是两种技术的智慧结晶：哈希和公钥加密。</p>
<h3 id="哈希和比特币区块链">哈希和比特币区块链</h3><p>比特币区块链是每笔比特币交易的账簿。它是一个区块序列，每个区块包含一组比特币交易。你可以把区块链想象成一系列的包裹，每个包裹装着十分钟内的交易记录。<br><img src="/image/0817/bVCjrwOH85M1w6AbzQYjQ.png"><br>你也可以想象这些包裹一个挨一个堆起来，最早的交易记录区块在最下面，而最新的则在最上面。挪动这个堆中的任何一个块，这个块之上的所有块就会倒下来。这让篡改很容易被发现。<br>每个块都有一个唯一的哈希，一个很大数字的指纹，用十六进制表达的话就是一段毫无规律的字符串。比如，某一个块的哈希可能是“00000000003e95b0ac78cb961d0“。<br>为了我们的讨论更加简单明了，我们用表情包代替大数字来表示哈希。我们假设第一个块的哈希是⚽️ （一个足球），第二个块的哈希是🐙（鱿鱼），第三个块的哈希是🌂（雨伞）。这个用表情包哈希表现的区块链看起来就是这样的：<br><img src="/image/0817/X076K6_GrBrlHG95-7oTgw.png"><br>还是之前的场景，伊丽莎白转给我5块钱的比特币，然后我在想转给你。我转账的这条记录会和其他新增区块里面的交易记录一起加入到区块链中。区块链中的每个块都能确定在序列中的位置因为它包含了前一个块的哈希值。换句话说，第一块不仅包含了一组交易记录，还有前一个块的哈希值（即🐙）。<br>假设比特币系统刚刚计算了区块 📦3的哈希值🌂。一旦我付给你5块，比特币网络就把我们的交易记录在下一个区块。我们称这个新的区块为📦4，它暂时还没有哈希值——现在这被标记为一个问题。<br><img src="/image/0817/t_1yzYLKrGTxhvAS7X5pWw.png"><br>有趣的部分就来了。被称为“矿工”的强劲的计算机通过计算来把📦4加到区块链。第一个成功计算出这个新块的哈希值即为胜出，赢家可以获得12.5比特币作为奖赏（这个值未来会不断缩小）。<br>这就是新的比特币是如何被挖掘的。一旦一个哈希值被成功得计算出来，它将立即广播给所有矿工。其他矿工可以校验这个值，把它加入他们手上区块的副本，然后再比赛寻找下一个区块的哈希值。<br>哈希计算很简单。笔记本电脑都能在一秒内计算出成千上万的哈希值。<br>然而在比特币网络，寻找找一个正确的哈希值平均花费矿工们十分钟，但是因为这不仅仅是计算哈希值。比特币网络要求哈希值非常非常小——和其他可能的哈希值比起来，这样让寻找一个合适的哈希值就变的极度繁琐了。哈希值可能是一个大到叹为观止的数字。和所有可能的值比起来，一个万亿级的数字也算小的了，就像地球在宇宙中一样渺小。<br>矿工们想要找到一个不大可能的小的哈希值，唯一方法就是一遍又一遍的重试。每次尝试都不一样。虽然矿工不能变化哈希的计算方式，但他们可以改变计算的内容。<br>矿工们为之求助于叫“临时变量”的东东，那就像上篇里面小狗眼睛上的一个像素的黑色跳蚤。<br><img src="/image/0717/9pLIk8bq-GuOHsFaK7vtcw.png"><br>回想一下，添加一个像素就让小狗照片的哈希值截然不同。对数字内容做一丁点儿的修改，也会使之哈希结果大不一样，且不可预测。<br>临时变量是盲目的猜测。在比特币区块中添加一个数字，经过尝试和错误的工程，以期望这个数字可以帮助计算出最后胜出的哈希值。矿工把这个区块所有的交易记录，加上前一个块的哈希值，再加上一个临时变量，然后计算哈希。每个矿工尝试不一样的临时变量，希望区块中加入它后可以产生一个符合条件的小的哈希值。事实上，成功的矿工也许需要尝试数百万个不同的临时变量。<br>如今，一般需要经过一千万亿尝试才能找到一个临时变量产生一个成功的哈希。因为有非常多的矿工，并且都在使用相当强悍的计算机，这样每十分钟会有一个胜出者。如果平均时间变得少于10分钟，比特币网络会自动通过要求更小的哈希值来加大运算难度。<br>金子值钱是因为金子是稀有金属，一个合适的哈希变得值钱也因为它是一个稀有的数字。这个数字的质量（小）让它变的很罕见。矿工简直是乱猜，通过千万亿计的猜测，期望成为第一个碰到一个数字（临时变量）可以用来生成满足比特币系统严苛条件的哈希值。比如，比特币系统的要求可能是要求哈希值要小于0000000003e95b0acc32ac089222。赢得这个挖矿的策略就是有足够强大的计算机能力来做非常多的尝试。<br>比特币网络要求哈希值小于某特定的大小。回到我们的表情包，让我们把这个限制想象地更友好一些：比如，我们说网络要求哈希值必须是一种动物。在矿工的第一次尝试，哈希值时这样子的：<br><img src="/image/0817/DMnySi1wHxtShgLQojwBgQ.png"><br>上面3个只有一个满足要求：樱花和梨都不是动物，但海豚是的。<br>由于第二个矿工发现了正确的哈希，他将获得奖励。这个奖励包含新的比特币，这就是这个过程被称为“挖矿”的原因，就像是矿工在挖掘新的比特币，也就像之前淘金一样。<br>如果挖矿进度太快，那比特币就会泛滥，引起通货膨胀。为了避免这种情况，比特币软件设计带有自适应限制机制。如果哈希值太容易被找到，网络就会选择一个更严格的限制。<br>假如，我们表情包区块链里面挖矿太快，为了解决这个，限制就会做一些调整：从下一个块开始，哈希值必须是一种动物，并且是一种带爪子的动物。<br>矿工们运行他们的哈希函数发现：<br><img src="/image/0817/DMnySi1wHxtShgLQojwBgQ.png"><br>没有一个哈希是带爪子的动物，所以矿工们继续尝试：<br><img src="/image/0817/QcV4WnMlAZftndtJ69dkyw.png"><br>现在，第三个矿工发现了一个正确的哈希：熊是有爪子的动物！然后这个矿工可以在网络中广播这个哈希值和相应块中的数据。由于哈希计算很快，其他矿工可以计算这个块的哈希来校验这个哈希值，🐻，是否满足限制条件。然后他们把这个块加入他们的区块链，这样他们和其他人保持着大约（或多或少）的同步。接着，矿工们开始收集下一个块的交易记录。<br>现在，区块链的哈希看起来是这样，包括了称为🐻的块。我转给你5块钱的交易就在这个块里。<br><img src="/image/0817/B4mj4242zqyz3HPMOoDbSw.png"></p>
<h3 id="公钥加密算法">公钥加密算法</h3><p>哈希是比特币依赖的数学概念中的一个，公钥加密算法则是另外一个。<br>在密码学中，人们总是用“Alice”和“Bob”作为相互交流的角色。我们就用他们来帮我们解释下公钥加密算法后面的基本原理。<br>假设Alice想给Bob发送一个装有机密文件的公文包。（在密码学里，Alice似乎一直在干这事儿）。如果Alice和Bob有相同的密钥，那就很简单了：她给公文包加一把锁，用她的钥匙锁上，然后发给Bob。<br><img src="/image/0817/hIiiQGNEQFfuduLEwsZRBA.gif" width="50%" height="50%"><br>Bob收到公文包之后，他可以用他的钥匙开锁——因为他的钥匙和Alice的是一样的，然后Bob就可以获取到机密文件了。这个过程就是密码学中的对称加密。<br>然而人们彼此之间往往没有这种匹配的密钥用来传送机密，因为安全地传输密钥可不是一件简单的事。如果Alice有一种私有且安全的方式给Bob发送一个密钥，那她也可以用这种方式直接把文件发给Bob。<br>因此Alice和Bob没有同一把锁的相同的钥匙。相反，他们每个人都有自己的锁和自己的钥匙，这样的话，他们其实可以不传输他们的钥匙。<br>我们来看怎么实现这个：<br>Alice用她的锁和钥匙把公文包锁上，然后发给Bob。Bob收到后，他并不能打开Alice的锁，但他可以用他自己的锁再把公文包锁上。<br><img src="/image/0817/nSxVF_7rpHLLUXL9cNqYzQ.gif" width="50%" height="50%"><br>然后发回给Alice：<br><img src="/image/0817/QEe-ni0-8_32yM84AwCL2w.gif" width="50%" height="50%"><br>然后Alice用她的钥匙把公文包上的她的锁打开。<br><img src="/image/0817/GEDj9yo_B1mJ6Ba8VueXOg.gif" width="50%" height="50%"><br>现在公文包上就只有Bob的锁了。Alice再把公文包发回给Bob：<br><img src="/image/0817/YPq9ZO7VS7edJ7_IsM_jMQ.gif" width="50%" height="50%"><br>现在Bob就可以轻松地打开公文包拿到文件了。<br>这样一来，Alice和Bob就没必要再去纠结如何悄悄地共享一个密钥了。他们只需要每个人都有自己的钥匙和锁就可以了。<br>但是要是另外一端的接收人不是你想的那个人呢？如果出了什么岔子，Bob变成了一头牛呢？<br><img src="/image/0817/rCnqfDbuZgQz0VWhWiltOg.png" width="50%" height="50%"><br>那就会这样了：</p>
<pre><code><span class="number">1.</span> Alice发送公文包。她以为她发给Bob了，但是其实她是发给了一头奶牛。
<span class="number">2.</span> 这头惊人聪明的奶牛在公文包上加上了它的锁并发回给Alice。
<span class="number">3.</span> Alice开心地以为收到的公文包上的锁是Bob的（其实是属于一头牛的），然后她打开了自己的锁并将公文包再发了出去。
<span class="number">4.</span> 奶牛打开公文包上的锁。
<span class="number">5.</span> 奶牛吃了机密文件。哞～
</code></pre><p>没有人想让他们的机密被奶牛消费，所以我们多做一步来保护我们的机密：Bob得让Alice准确地知道他的锁长什么样。这样Alice可以校验收到的公文包上新加的锁是不是Bob的。<br>事实上，Bob复制了他的锁，并公开，随处可见。让每个人都知道Bob的锁的样子没有关系，因为只有Bob才有钥匙打开他的锁。与此同时，这可以让Alice可以识别Bob的锁。她可以检查公文包上的第二把锁是不是Bob的，然后再打开她自己的锁。<br>我们是用物理的锁和钥匙，那要复制和分发锁并非易事。还好我们现在是在说数字内容，我们说的数字密钥和锁，都是数字。<br>这个锁是一个公开的数字，而钥匙是私密的数字。这个私密的数字，即为私钥，可以用来“解开”公开的内容。公开的数字，也许有点儿容易弄混，就是公钥。<br>这就是公钥加密算法。<br>人们需要谨慎保管他们的私钥，因为私钥可以解密任何它对应的公钥。（在密码学上，这个解密的过程有时被称为签名。）人们广泛公开他们的公钥，这样其他人就知道这个特定的锁到底锁了什么内容。<br>在比特币系统中，公钥加密算法被用来证明所有权。为了解释具体是怎么运作的，首先我们需要弄清几个术语。在比特币系统中，有私钥，公钥和地址。<br><img src="/image/0817/e9hfJqnUO_NAadJnnEI5JA.png" width="50%" height="50%"><br>不像Alice和Bob传文件的例子，比特币系统里的密钥不是用来加密的。没有什么神秘的公文包需要解密。这些密钥是用来证明所有权的。<br>在比特币世界里，Alice不再给Bob发送秘密公文包。相反，她有一个透明的玻璃盒子，里面装了她的锁和比特币。<br><img src="/image/0817/M6BIc6Qp1F7PGOb2jzB9zQ.png" width="50%" height="50%"><br>如果Alice要转比特币给Bob，她需要做两件事情：</p>
<pre><code><span class="number">1.</span> Alice要把Bob的锁放到盒子里。这很简单，因为Bob到锁其实就是一个公开的数字。这样以来，Bob可以通过打开他的锁来证明他有拥有这个盒子。
<span class="number">2.</span> Alice需要证明盒子里面的第一把锁是她的，而不是别人的。她可以证明这一点，因为她可以用她的钥匙来打开那把锁。她的钥匙就是一串没有分享给任何人的数字。
</code></pre><p><img src="/image/0817/6sx6QAetKVwY3T8Xhl9pSg.png" width="50%" height="50%"><br>然后，当Bob决定把这些比特币转给别人（比如说Carlos）的时候，他也要做同样的事情：他添加Carlos的锁并用他的私钥签署这笔交易。<br>在这个场景里，锁到底是什么？总地来说，锁就是公钥。但比特币协议在公钥加密算法有些改变——不光包含了Bob公钥本身，还加入了Bob的比特币地址。比特币地址从公钥中衍生出来。这就像是Alice放了一个Bob锁的特殊代表。并且，一个公钥可以产生几乎无数多的地址，Bob每次可以用一个不同的地址，如果他想的话。<br>我们再回来之前我转给你的那5块钱。我把5块钱转到了你的比特币地址——那是根据你的公钥生成的。而的你公钥是从你的私钥生成的。在数学上，你的比特币地址和你的私钥是绑定的。如果你有某些地址对应的私钥，那你也持有这些地址上的比特币。<br>如果你想花掉这5块钱，那你需要创建一个新的交易，交易里面包含了收款人的地址，并用你的私钥签名。这就像用收件人的锁锁上公文包并且解开你自己的锁。<br>另外使用地址还有一个有趣的影响，那就是，比特币是近乎匿名的。<br>比特币是化名的，因为你的地址是你的化名。比特币不会关联你的姓名，唯一需要的就是你的私钥。<br>只有你有你的私钥，你就拥有你的比特币。随便你怎么玩。</p>
<hr>
<p><em>到目前为止，在<a href="http://brightonzhang.com/2017/07/bitcoin-explained-with-emoji-1/">第一章</a>，我们了解了比特币是去中心化的货币，而不是由任何政府和财团发行的，以及什么是哈希。在<a href="http://brightonzhang.com/2017/08/bitcoin-explained-with-emoji-2/">第二章</a>，我们了解了比特币矿工如何用哈希真正地赚钱以及密码学如何保障比特币的唯一性和不可复制性却又可以转账。<br>在第三章，我们将介绍怎么用比特币和区块链来不止赚钱，以及这些技术如何成就新的金融工具。</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2017/08/bitcoin-explained-with-emoji-2/" data-id="cj6khx4nh00062xpshabhnhsk" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2017/08/bitcoin-explained-with-emoji-2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/区块链/">区块链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/密码学/">密码学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比特币/">比特币</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bitcoin-explained-with-emoji-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/bitcoin-explained-with-emoji-1/" class="article-date">
  <time datetime="2017-07-30T13:24:50.000Z" itemprop="datePublished">07-30-2017</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/bitcoin-explained-with-emoji-1/">比特币的另类解释之表情包·上篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文翻译至<a href="https://twitter.com/_tessr" target="_blank" rel="external">Tess Rinearson</a>的<a href="https://medium.com/@tessr/making-money-530d2bb2b8f7" target="_blank" rel="external">Making Money Bitcoin Explained (with Emoji), Part 1</a>，该翻译和发布已获得原作者允许。由于本人能力和时间有限，翻译如有纰漏或不妥，还请见谅。若对内容和翻译有任何建议或意见，欢迎交流。</p>
<hr>
<p><img src="/image/0717/yD-kFo0s2mzkURb1YGZTvA.png" alt=""><br><em>比特币提供了一种颠覆存储和消费电子货币的途径，也有改变其它领域的潜力。不一定只有数学家或密码学家才能理解比特币。当你开始了解这个系统是怎么运作的，你可能会很开心。本文共有三章，下面是第一章。</em></p>
<hr>
<p>比如说，我在网上给你发送一部电影或一首歌曲。我将影片文件附到一封电子邮件里面，一旦我点发送，你就拥有了这部影片。你可以欣赏它也可以删除，任你处置。<br>但记住一点：我仍然还有这个文件的副本。<br><img src="/image/0717/Ro6DQmNVLwcXMP6BQL01ng.gif" width="50%" height="50%"><br>这是数字信息在网络传输的典型方式。你没有真正地传送，你只是做了复制。到目前为止，这种方式非常有效，也许不合法或不公平，但拷贝歌曲或电影还不至于摧毁经济。<br>但我们想想复制货币。<br>如果我给了你一块钱，那我不再拥有这一块钱（副本）了。用电子邮件产生无穷的电子货币，刚开始似乎很有吸引力，但如果每个人都开始这么做呢？那势必通货膨胀，经济崩塌。<br><img src="/image/0717/aLNV2jF6edP3iAD-Y3xqBg.png" alt=""><br>传统上，在银行电汇和信用卡的世界里，数字货币被集成追踪以防止复制。比如在你的银行，有一个数据库，用来校验谁持有数字货币。众所周知，这个系统依赖中心化机构，？。当然，这个中心化机构完全管理着你的货币。<br>但还有没有其它方法呢？我们能不能依赖一个不被某个政党控制的去中心化机构能，而不是依赖一个不可靠的中心化机构来管理每个人的资产。如果我们认可货币的价值不是因为我们相信政府的权力而是数学的力量。<br>我们再来看比特币。</p>
<h3 id="比特币介绍">比特币介绍</h3><p>比特币（Bitcoin）是一个不和任何政府或组织关联的数字货币系统。<br>澄清一下，比特币（bitcoin，小写字母）也用来称呼这种货币本身。比特币系统创立于2009年，但是比特币货币是通过一个叫挖矿的过程持续生成的。其过程就像挖金矿，只不过是在数字化的二十一世纪。<br>比特币网络的所有交易都被永久纪录在一个叫区块链的很长的表单上。这个表单不是一个由中心机构管控的机密文件，它被公开地广泛传播，每一个参与的计算机都有一个副本。<br><img src="/image/0717/9R0l9KMTkr6Ko1tJF6vgDQ.png" alt=""><br>比特币区块链是一份不可改变的，公开的，分布式的账簿。<br>不可改变，是指一条纪录一旦被加入到区块链几个小时，那将再也不可能修改或者删除它。因为有很多基于它的交易纪录被添加到了区块链后面。<br>公开，是指每个人，不光是银行员工，都可以查看区块链。但也并不是说你可以准确地知道是谁支付或者接受了交易，因为纪录都是匿名的。身份信息都通过一个化名来隐藏，每个化名一般也只使用较短的时间。<br>分布式，即全世界的电脑都可以持有同步的区块链副本。没有所谓的原件，所有副本都是平等的。<br>最后，账簿，区块链是一个交易纪录表单。可以认为他就像你的支付宝账单。<br>这个分布式账簿之所以被称为区块链是因为单个交易组成一个大的“块”，然后这些块按序列链在一起。这要比逐个添加单笔交易要快。每十分钟创建一个新的区块来记录交易。<br>为了更好地解释不可修改，公开，分布式账簿的威力，我们想象一个常见但假设的关于价值5块钱的比特币场景。（比特币的价值上下波动，单个比特币价值远超5块钱了）。<br>我们假设，我的朋友伊丽莎白用比特币转给我5块，这条交易就会被记录在区块链里——所有的交易都会被记录在区块链里。现在所有的区块链副本都显示这5块钱属于我——之前是属于伊丽莎白的。接下来，我再把这5块钱转给你。这里涉及的三个人，我，你和伊丽莎白，都不需要向中心数据库查询归属和请求许可。授权机构是去中心化的，它在区块链的每一份副本里，无处不在。<br>你也许好奇，伊丽莎白从哪得到转给我的比特币的。<br>最简单的答案就是也许别人转给她的。这（转账）几乎是所有人获得比特币的方式。<br>但是这些比特币都得先生成出来。到底是怎么生成的呢？</p>
<h3 id="比特币如何产生">比特币如何产生</h3><p>美元是由美国政府印刷生产的，其它传统的货币也是由各个政府发行的。很久以前，美元的价值是由美国国库里等值的黄金保证的。在那个时候，发行美元就需要有等值的黄金，所以有淘金热。<br>比特币也是通过一个叫挖矿的过程产生的。这是一个通过计算机和软件来完成的数字挖矿，不再需要炸药和铲子。为了把新的交易区块加入到区块链，需要解决一个繁重的数学问题。第一个解决这个问题的矿工会得到比特币的奖励。这就是比特币的挖矿过程。<br>换句话说，挖矿做两件事：向区块链添加新的区块和创造新的比特币。矿工们比赛解决的数学问题就是哈希。</p>
<h3 id="哈希101">哈希101</h3><p>哈希值是数据的指纹，哈希值可以唯一地标识一份数字内容，包括图片，相簿，电影，密码，文本……哈希值根据数字内容计算生成，这个计算过程被称为哈希。哈希值的形式可以是字符串，也可以是数字，或者其他符号。<br>哈希是计算机科学的核心内容，使用广泛。为了安全，网络服务一般保存用户密码的哈希值而不是真实的密码，当你登陆时也是比较你输入密码的哈希值。Facebook使用哈希来验证图片是否允许上传。Facebook没有人盯着每一张图片去看它是涉及暴力或色情。相反，Facebook把标记为不合适的图片计算哈希值，创建一个违规内容的表单。每当有图片上传，Facebook用相同的算法计算哈希值，如果将计算结果和违规内容表里的数据比较，如果有匹配的，Facebook就知道这是一张违规图片。<br>一般的哈希计算软件，输入原始数据，如一张照片，然后输出一段毫无规律的字符串，即哈希值。<br>例如，我们把这张小狗的图片做SHA-256计算。<br><img src="/image/0717/NZN-iuwDMRol0fxunqkIEA.jpg" alt=""><br>显然，这张萌萌的小狗照片没有违反Facebook的任何规范。一目了然。但是Facebook没有人来看这张图片，Facebook软件会检查这张图片的哈希值：<br>8EC9D4718F919C6087CA589EDA09E7DD9A7ACCDB820F42B4196E1D0D4BEDE77A<br>这是这张图片的十六进制表示的哈希值。完全没有看不出一点小狗的萌。<br>哈希函数的一个很有趣的特点就是如果稍稍改变一点输入的数据，其结果就会截然不同。比如说，我们修改这张小狗图片里面的一个像素——在小狗的眼睛上方加了一只一个像素的黑色跳蚤。<br><img src="/image/0717/9pLIk8bq-GuOHsFaK7vtcw.png" alt=""><br>然后我们再计算这个图片的哈希值，哪怕我们只改了一个像素，但结果却完全不同。<br>039E1AF92F7D00775ECE35C2216FC3F7F0BBCD31F912A105D2601380D8DEABA2<br>我们可以在本文接下来的部分中用真实的内容和真实的哈希值，但是哈希往往不方便阅读和区分。相反，我们用表情包来代表哈希的输入和输出。在下文的例子中，用猫脸代表哈希的输入（用来计算哈希的内容），用蝴蝶结代表输入（哈希值）。<br><img src="/image/0717/meFq2cQdP8I_Q74dYN7fYQ.png" alt=""><br>试想Facebook，Facebook计算了两幅违规图片——如🚫和❌——哈希结果是💩和💀。<br><img src="/image/0717/IzjzG_s6l-vjha7OTfzfiA.png" alt=""><br>后来，有人上传了一张图片，我们先叫它”?”，因为Facebook还不知道它是啥。Facebook计算了改图片的哈希，结果是💩。<br><img src="/image/0717/eh_ECwi4aQBcORo3Zk7gZA.png" alt=""><br>尽管没人看过这个神秘图片，Facebook知道这是副违规图片🚫——哈希值是匹配的。不需要有人直接去检查新上传的图片，因为这幅图片和某一副违规图片的哈希值是一样的。<br>图片识别只是哈希的一个应用。比特币挖矿，即创造新的比特币和添加新交易到区块链，则是哈希的另一个应用。</p>
<hr>
<p><em>到目前为止，在<a href="http://brightonzhang.com/2017/07/bitcoin-explained-with-emoji-1/">第一章</a>，我们已经知道了比特币是一种去中心化的，不由任何政府或财团发行的货币。另外我们还了解了哈希的基本概念。在<a href="http://brightonzhang.com/2017/08/bitcoin-explained-with-emoji-2/">第二章</a>，我们将讲述比特币矿工如何用哈希去赚钱，以及密码学如何保障比特币的唯一性和不可复制性却又可以转账。</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2017/07/bitcoin-explained-with-emoji-1/" data-id="cj6khx4no000d2xpsd5k463n4" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2017/07/bitcoin-explained-with-emoji-1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/区块链/">区块链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/密码学/">密码学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比特币/">比特币</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ubuntu-on-windows" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/ubuntu-on-windows/" class="article-date">
  <time datetime="2016-08-14T06:18:26.000Z" itemprop="datePublished">08-14-2016</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/ubuntu-on-windows/">Ubuntu on Windows 初体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在build 2016开发者大会上，微软发布了Bash on Ubuntu on Windows。在windows上运行原生bash，听起来还是很有吸引力了。终于可以抛弃那个鸡肋的cmd，还有那个很多人都不知道PowerShell了。<br>连续三个周末都要跑医院之后，今天终于有空了，找了一台windows的笔电，升级了周年更新，可以来体验下Bash on Ubuntu on Windows了。</p>
<p>安装完windows 10周年更新之后，我并没有找到任何的bash入口。google了下，原来这个功能还是隐藏在开发者模式中。如果想用bash，需要先到 设置／更新和安全／针对开发者 中选择开发者模式，然后在  控制面板／程序／启用和关闭windows功能 中启用 “适用于Linux的Windows子系统(Beta)”，然后运行cmd，输入bash，再y进行安装。安装下载速度并不稳定，我下载了3次才下载成功。下载安装完成之后，会提示设置UNIX用户名和密码，然后就基本安装设置完成，可以使用bash了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brighton@DESKTOP-BQ3SOKG:~$ uname -a&#10;Linux DESKTOP-BQ3SOKG 3.4.0+ #1 PREEMPT Thu Aug 1 17:06:05 CST 2013 x86_64 x86_64 x86_64 GNU/Linux&#10;brighton@DESKTOP-BQ3SOKG:~$ cat /etc/issue&#10;Ubuntu 14.04.4 LTS \n \l</span><br></pre></td></tr></table></figure></p>
<p>这里看到运行的是Ubuntu 14.04。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brighton@DESKTOP-BQ3SOKG:~$ cd /mnt/c/&#10;Config.Msi/                ProgramData/               ProgramPortable/           $SysReset/                 Users/                     Windows.old/&#10;Intel/                     Program Files/             Recovery/                  System Volume Information/ Windows/&#10;PerfLogs/                  Program Files (x86)/       $RECYCLE.BIN/              Tencent/                   $WINDOWS.~BT/&#10;brighton@DESKTOP-BQ3SOKG:~$ cd /mnt/c/Users/lvyujuan/Documents/&#10;brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents$ mkdir test&#10;brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents$ cd test/&#10;brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents/test$</span><br></pre></td></tr></table></figure>
<p>Windows目录是挂载在/mnt/目录下，可以直接操作windows目录。</p>
<p>尝试用vi创建一个Hello world C语言程序，并用gcc编译。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents/test$ vi hello.c&#10;brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents/test$ gcc hello.c -o hello&#10;The program &#39;gcc&#39; is currently not installed. You can install it by typing:&#10;sudo apt-get install gcc</span><br></pre></td></tr></table></figure></p>
<p>Oh, 没有集成gcc，那装个呗。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents/test$ sudo apt-get install gcc&#10;sudo: unable to resolve host DESKTOP-BQ3SOKG&#10;Reading package lists... Done&#10;Building dependency tree&#10;Reading state information... Done&#10;The following packages were automatically installed and are no longer required:&#10;  libfreetype6 os-prober&#10;Use &#39;apt-get autoremove&#39; to remove them.&#10;The following extra packages will be installed:&#10;  binutils cpp cpp-4.8 gcc-4.8 gcc-4.8-base libasan0 libatomic1 libc-dev-bin&#10;  libc6 libc6-dev libcloog-isl4 libgcc-4.8-dev libgmp10 libgomp1 libisl10&#10;  libitm1 libmpc3 libmpfr4 libquadmath0 libstdc++6 libtsan0 linux-libc-dev&#10;  manpages-dev&#10;Suggested packages:&#10;  binutils-doc cpp-doc gcc-4.8-locales gcc-multilib make autoconf automake1.9&#10;  libtool flex bison gdb gcc-doc gcc-4.8-multilib gcc-4.8-doc libgcc1-dbg&#10;  libgomp1-dbg libitm1-dbg libatomic1-dbg libasan0-dbg libtsan0-dbg&#10;  libquadmath0-dbg glibc-doc&#10;The following NEW packages will be installed:&#10;  binutils cpp cpp-4.8 gcc gcc-4.8 libasan0 libatomic1 libc-dev-bin libc6-dev&#10;  libcloog-isl4 libgcc-4.8-dev libgmp10 libgomp1 libisl10 libitm1 libmpc3&#10;  libmpfr4 libquadmath0 libtsan0 linux-libc-dev manpages-dev&#10;The following packages will be upgraded:&#10;  gcc-4.8-base libc6 libstdc++6&#10;3 upgraded, 21 newly installed, 0 to remove and 45 not upgraded.&#10;Need to get 24.3 MB of archives.&#10;After this operation, 70.6 MB of additional disk space will be used.&#10;Do you want to continue? [Y/n] y&#10;Get:1 http://archive.ubuntu.com/ubuntu/ trusty-updates/main gcc-4.8-base amd64 4.8.4-2ubuntu1~14.04.3 [16.2 kB]&#10;Get:2 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libstdc++6 amd64 4.8.4-2ubuntu1~14.04.3 [259 kB]&#10;Get:3 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libc6 amd64 2.19-0ubuntu6.9 [4,717 kB]&#10;Get:4 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libasan0 amd64 4.8.4-2ubuntu1~14.04.3 [63.1 kB]&#10;Get:5 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libatomic1 amd64 4.8.4-2ubuntu1~14.04.3 [8,636 B]&#10;Get:6 http://archive.ubuntu.com/ubuntu/ trusty/main libgmp10 amd64 2:5.1.3+dfsg-1ubuntu1 [218 kB]&#10;Get:7 http://archive.ubuntu.com/ubuntu/ trusty/main libisl10 amd64 0.12.2-1 [419 kB]&#10;Get:8 http://archive.ubuntu.com/ubuntu/ trusty/main libcloog-isl4 amd64 0.18.2-1 [57.5 kB]&#10;Get:9 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libgomp1 amd64 4.8.4-2ubuntu1~14.04.3 [23.1 kB]&#10;Get:10 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libitm1 amd64 4.8.4-2ubuntu1~14.04.3 [28.5 kB]&#10;Get:11 http://archive.ubuntu.com/ubuntu/ trusty/main libmpfr4 amd64 3.1.2-1 [203 kB]&#10;Get:12 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libquadmath0 amd64 4.8.4-2ubuntu1~14.04.3 [126 kB]&#10;Get:13 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libtsan0 amd64 4.8.4-2ubuntu1~14.04.3 [94.9 kB]&#10;Get:14 http://archive.ubuntu.com/ubuntu/ trusty/main libmpc3 amd64 1.0.1-1ubuntu1 [38.4 kB]&#10;Get:15 http://archive.ubuntu.com/ubuntu/ trusty-updates/main binutils amd64 2.24-5ubuntu14.1 [2,081 kB]&#10;Get:16 http://archive.ubuntu.com/ubuntu/ trusty-updates/main cpp-4.8 amd64 4.8.4-2ubuntu1~14.04.3 [4,595 kB]&#10;Get:17 http://archive.ubuntu.com/ubuntu/ trusty/main cpp amd64 4:4.8.2-1ubuntu6 [27.5 kB]&#10;Get:18 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libgcc-4.8-dev amd64 4.8.4-2ubuntu1~14.04.3 [1,688 kB]&#10;Get:19 http://archive.ubuntu.com/ubuntu/ trusty-updates/main gcc-4.8 amd64 4.8.4-2ubuntu1~14.04.3 [5,047 kB]&#10;Get:20 http://archive.ubuntu.com/ubuntu/ trusty/main gcc amd64 4:4.8.2-1ubuntu6 [5,098 B]&#10;Get:21 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libc-dev-bin amd64 2.19-0ubuntu6.9 [69.0 kB]&#10;Get:22 http://archive.ubuntu.com/ubuntu/ trusty-updates/main linux-libc-dev amd64 3.13.0-93.140 [771 kB]&#10;Get:23 http://archive.ubuntu.com/ubuntu/ trusty-updates/main libc6-dev amd64 2.19-0ubuntu6.9 [1,910 kB]&#10;Get:24 http://archive.ubuntu.com/ubuntu/ trusty/main manpages-dev all 3.54-1ubuntu1 [1,820 kB]&#10;Fetched 24.3 MB in 2min 21s (172 kB/s)&#10;Preconfiguring packages ...&#10;(Reading database ... 25004 files and directories currently installed.)&#10;Preparing to unpack .../gcc-4.8-base_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking gcc-4.8-base:amd64 (4.8.4-2ubuntu1~14.04.3) over (4.8.4-2ubuntu1~14.04.1) ...&#10;Setting up gcc-4.8-base:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;(Reading database ... 25004 files and directories currently installed.)&#10;Preparing to unpack .../libstdc++6_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking libstdc++6:amd64 (4.8.4-2ubuntu1~14.04.3) over (4.8.4-2ubuntu1~14.04.1) ...&#10;Setting up libstdc++6:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;Processing triggers for libc-bin (2.19-0ubuntu6.7) ...&#10;(Reading database ... 25004 files and directories currently installed.)&#10;Preparing to unpack .../libc6_2.19-0ubuntu6.9_amd64.deb ...&#10;Unpacking libc6:amd64 (2.19-0ubuntu6.9) over (2.19-0ubuntu6.7) ...&#10;Setting up libc6:amd64 (2.19-0ubuntu6.9) ...&#10;Processing triggers for libc-bin (2.19-0ubuntu6.7) ...&#10;Selecting previously unselected package libasan0:amd64.&#10;(Reading database ... 25004 files and directories currently installed.)&#10;Preparing to unpack .../libasan0_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking libasan0:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package libatomic1:amd64.&#10;Preparing to unpack .../libatomic1_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking libatomic1:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package libgmp10:amd64.&#10;Preparing to unpack .../libgmp10_2%3a5.1.3+dfsg-1ubuntu1_amd64.deb ...&#10;Unpacking libgmp10:amd64 (2:5.1.3+dfsg-1ubuntu1) ...&#10;Selecting previously unselected package libisl10:amd64.&#10;Preparing to unpack .../libisl10_0.12.2-1_amd64.deb ...&#10;Unpacking libisl10:amd64 (0.12.2-1) ...&#10;Selecting previously unselected package libcloog-isl4:amd64.&#10;Preparing to unpack .../libcloog-isl4_0.18.2-1_amd64.deb ...&#10;Unpacking libcloog-isl4:amd64 (0.18.2-1) ...&#10;Selecting previously unselected package libgomp1:amd64.&#10;Preparing to unpack .../libgomp1_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking libgomp1:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package libitm1:amd64.&#10;Preparing to unpack .../libitm1_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking libitm1:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package libmpfr4:amd64.&#10;Preparing to unpack .../libmpfr4_3.1.2-1_amd64.deb ...&#10;Unpacking libmpfr4:amd64 (3.1.2-1) ...&#10;Selecting previously unselected package libquadmath0:amd64.&#10;Preparing to unpack .../libquadmath0_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking libquadmath0:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package libtsan0:amd64.&#10;Preparing to unpack .../libtsan0_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking libtsan0:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package libmpc3:amd64.&#10;Preparing to unpack .../libmpc3_1.0.1-1ubuntu1_amd64.deb ...&#10;Unpacking libmpc3:amd64 (1.0.1-1ubuntu1) ...&#10;Selecting previously unselected package binutils.&#10;Preparing to unpack .../binutils_2.24-5ubuntu14.1_amd64.deb ...&#10;Unpacking binutils (2.24-5ubuntu14.1) ...&#10;Selecting previously unselected package cpp-4.8.&#10;Preparing to unpack .../cpp-4.8_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking cpp-4.8 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package cpp.&#10;Preparing to unpack .../cpp_4%3a4.8.2-1ubuntu6_amd64.deb ...&#10;Unpacking cpp (4:4.8.2-1ubuntu6) ...&#10;Selecting previously unselected package libgcc-4.8-dev:amd64.&#10;Preparing to unpack .../libgcc-4.8-dev_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking libgcc-4.8-dev:amd64 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package gcc-4.8.&#10;Preparing to unpack .../gcc-4.8_4.8.4-2ubuntu1~14.04.3_amd64.deb ...&#10;Unpacking gcc-4.8 (4.8.4-2ubuntu1~14.04.3) ...&#10;Selecting previously unselected package gcc.&#10;Preparing to unpack .../gcc_4%3a4.8.2-1ubuntu6_amd64.deb ...</span><br></pre></td></tr></table></figure></p>
<p>Done.<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents/test$ gcc hello.c -o hello</span><br></pre></td></tr></table></figure></p>
<p>编译成功，看一下生成的文件。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents/test$ file hello&#10;hello: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=11ac1a45fd5649b002ee581fe3b3f9565639d729, not stripped&#10;brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents/test$ readelf -h hello&#10;ELF Header:&#10;  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00&#10;  Class:                             ELF64&#10;  Data:                              2&#39;s complement, little endian&#10;  Version:                           1 (current)&#10;  OS/ABI:                            UNIX - System V&#10;  ABI Version:                       0&#10;  Type:                              EXEC (Executable file)&#10;  Machine:                           Advanced Micro Devices X86-64&#10;  Version:                           0x1&#10;  Entry point address:               0x400440&#10;  Start of program headers:          64 (bytes into file)&#10;  Start of section headers:          4472 (bytes into file)&#10;  Flags:                             0x0&#10;  Size of this header:               64 (bytes)&#10;  Size of program headers:           56 (bytes)&#10;  Number of program headers:         9&#10;  Size of section headers:           64 (bytes)&#10;  Number of section headers:         30&#10;  Section header string table index: 27</span><br></pre></td></tr></table></figure></p>
<p>可以看到，生成的可执行程序hello是ELF 64位，UNIX运行平台的文件。执行一下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brighton@DESKTOP-BQ3SOKG:/mnt/c/Users/lvyujuan/Documents/test$ ./hello&#10;Hello, world.</span><br></pre></td></tr></table></figure></p>
<p>运行成功。</p>
<p>通过上面的测试，我们可以运行基本的shell命令，可以通过apt-get安装程序，可以直接运行linux可执行程序。</p>
<p>按照微软的介绍，这不是虚拟机，不是容器，不是像cygwin那样，这是在Windows上直接运行Ubuntu的ELF的二进制程序，直接将Linux的系统跳用转变为windws的系统调用，微软称之为“Windows Subsystem for Linux”——就是前面控制面板中的“适用于Linux的Windows子系统”————和Ubuntu合作开发。</p>
<p>之前，Ubuntu一直把微软作为头号对手。2004年创始人马克﹒舍特尔沃斯发布了Ubuntu 的 Bug #1————Microsoft has a majority market share。马克 认为，微软占据了大多数新兴的桌面PC市场，这是一个Bug，Ubuntu要设法修正它。我自己一直很欣赏这份幽默。<br>在2013年马克宣布关闭该Bug，他表示Windows已经被iOS和Android打败了。</p>
<p>现在Ubuntu和微软合作为我们带来“Windows Subsystem for Linux”。正如马克所言：与其把眼睛放在别人身上，不如多花点精力创造属于我们自己的辉煌。</p>
<p>PS：<br>最新发现visual code里面的终端窗口比cmd那个不知道好看多少倍，对复制粘贴也支持地更好，推荐体验。</p>
<p>参考资料：<br><a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" target="_blank" rel="external">Bash on Ubuntu on Windows</a><br><a href="https://bugs.launchpad.net/ubuntu/+bug/1" target="_blank" rel="external">Microsoft has a majority market share</a></p>
<!--
最后贴一张图  
![](/image/ubuntu-on-windows.jpg)
-->

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2016/08/ubuntu-on-windows/" data-id="cj6khx4mx00002xpsj6svku35" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2016/08/ubuntu-on-windows/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mac-notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/mac-notes/" class="article-date">
  <time datetime="2016-06-10T07:05:07.000Z" itemprop="datePublished">06-10-2016</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/mac-notes/">MAC使用笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="启动root用户">启动root用户</h1><p>OS X Lion (10.7) 和更高版本</p>
<ul>
<li>从 Apple 菜单中选取“系统偏好设置”。</li>
<li>从“显示”菜单中选取“用户与群组”。</li>
<li>点按锁图标并使用管理员帐户进行鉴定。</li>
<li>点按“登录选项”。</li>
<li>点按右下方的“编辑”或“加入”按钮。</li>
<li>点按“打开目录实用工具”按钮。</li>
<li>点按“目录实用工具”窗口中的锁图标。</li>
<li>输入管理员帐户名称和密码，然后点按“好”。</li>
<li>从“编辑”菜单中选取“启用 Root 用户”。</li>
<li>在“密码”和“验证”栏中输入您想要使用的 root 密码，然后点按“好”。</li>
</ul>
<p>详请参考：<a href="https://support.apple.com/zh-cn/HT204012" target="_blank" rel="external">https://support.apple.com/zh-cn/HT204012</a></p>
<h1 id="启动项">启动项</h1><p>该节主要参考至 <a href="http://www.tanhao.me/talk/1287.html/" target="_blank" rel="external">http://www.tanhao.me/talk/1287.html/</a><br>Mac OS X的开机启动项分为3种：Login Items，Launchd Daemon和Startup Items。</p>
<h6 id="Login_Items">Login Items</h6><p>Login Item可能时我们见到的最后的，就是在 “系统偏好设置／用户与群组／登录项”里面设置的。其配置文件时保存在 $HOME/Library/Preferences/com.apple.loginitems.plist下面。</p>
<h6 id="Lauchd_Daemon">Lauchd Daemon</h6><p>Launched Daemon是由launchd来负责启动的。launchd是内核加载之后启动的第一个进程。launchd用来完成系统初始化。launchd首先加载/System/Library/LaunchDaemons/和/Library/LaunchDaemons/目录下的launch-on-demand system-level daemon（这些是系统启动后立即启动的进程，是守护进程）。然后启动/System/Library/LaunchAgents, /Library/LaunchAgents 和$HOME/Library/LaunchAgents 下面的launch－on－demand user agent（这些是用户登录后启动的进程）。<br>我安装的tiger VPN的client的启动就是配置在/Library/LaunchAgents／com.tigeratwork.tigervpn.plist。<br>可以通过直接删除plist文件来移除启动项，也可以通过luanchctl命令来修改启动项。<br>e.g. sudo launchctl unload -w com.tigeratwork.tigervpn.plist #这样就可以移除tiger vpn client的开机自启动。<br>关于launchctl可以参考：<a href="http://ss64.com/osx/launchctl.html" target="_blank" rel="external">http://ss64.com/osx/launchctl.html</a><br>执行launchctl unload －w之后，相应的plist文件还在，但重启之后的确不再启动了。我还没有找到配置文件保存在哪。<br>更多Launchd Daemon可以参考：<a href="https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html</a></p>
<h6 id="Startup_Items">Startup Items</h6><p>Startup Items是系统启动过程中运行的程序，一般在/System/Library/StartupItems和/Library/StartupItems目录下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2016/06/mac-notes/" data-id="cj6khx4nf00052xpsg9wg3p5v" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2016/06/mac-notes/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sorting-algorithms" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/sorting-algorithms/" class="article-date">
  <time datetime="2016-02-05T02:29:13.000Z" itemprop="datePublished">02-05-2016</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/sorting-algorithms/">排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="冒泡排序_Bubble_Sort">冒泡排序 Bubble Sort</h2><p>冒泡排序重复的遍历要排序的数列，一次比较两个元素，如果两者顺序错误就交换。这样越小（大）大元素会经过交换慢慢“浮”到数列的顶端，故名冒泡排序。</p>
<p>冒泡排序算法运作如下：（从小到大）</p>
<ol>
<li>比较相邻的元素，如果第一个比第二个大，就交换两个。</li>
<li>对每一对相邻元素作同样的操作，从第一对到最后一对。这步做完之后，最后的元素会是最大的。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复以上步骤，直到没有任何一对元素需要比较。</li>
</ol>
<p>C++实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">				swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析">复杂度分析</h4><p>时间复杂度：O(n^2)<br>最优时间复杂度:O(n)<br>平均时间复杂度:O(n^2)<br>空间复杂度：总共O(n)，需要辅助空间O(1)</p>
<hr>
<h2 id="插入排序_Insertion_Sort">插入排序 Insertion Sort</h2><p>插入排序是通过构建有序序列，对于未排序元素，在已排序序列中找到相应位置并插入。插入排序应该是平时扑克和麻将中用的最多的。</p>
<p>插入排序算法运作如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已排序。</li>
<li>取下一个元素，在已排序序列中从后向前扫描。</li>
<li>如果该元素大于新元素，将该元素移到下一个位置。</li>
<li>重复步骤3，直到找到已排序的元素小于或等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2～5</li>
</ol>
<p>C++实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	T temp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line"> 		temp = arr[i];</span><br><span class="line"> 		j = i - <span class="number">1</span>; </span><br><span class="line"> 		<span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--)</span><br><span class="line"> 			arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line"> 		arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-1">复杂度分析</h4><p>时间复杂度：O(n^2)<br>最优时间复杂度:O(n)<br>平均时间复杂度:O(n^2)<br>空间复杂度：总共O(n)，需要辅助空间O(1)</p>
<p>插入排序需要比较操作次数为 (n-1) 到 n(n-1)/2 次。最好情况，已排序，比较 n-1 次即可。最快情况，逆序，需要比较 (n-1) + (n-2) + … + 1 次。<br>插入排序的赋值操作次数是比较操作次数加上(n-1)次。<br>平均来说插入排序算法复杂度为O(n^2)。<br>因此，插入排序不适合对于数据量较大的排序应用。如果需要排序的数据量很小，如小于千，那么插入排序还是个不错的选择。插入排序在工业级库中也有广泛应用，在STL的sort算法和stblib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p>
<hr>
<h2 id="选择排序_Selection_Sort">选择排序 Selection Sort</h2><p>选择排序可能是人类思维中最直观的排序，从一堆杂乱的元素中按顺序挑出元素排列。</p>
<p>选择排序运作如下：</p>
<ol>
<li>在未排序序列中找出最小的元素，存放到排序序列的起始位置。</li>
<li>从剩余未排序元素中找出最小元素，放到已排序序列的末尾。</li>
<li>重复上述步骤，直到所有元素排列完毕。</li>
</ol>
<p>C++实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, min;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		min = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">			<span class="keyword">if</span> (arr[min] &gt; arr[j])</span><br><span class="line">				min = j;</span><br><span class="line">		swap(arr[i], arr[min]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-2">复杂度分析</h4><p>时间复杂度：O(n^2)<br>最优时间复杂度:O(n^2)<br>平均时间复杂度:O(n^2)<br>空间复杂度：总共O(n)，需要辅助空间O(1)</p>
<p>选择排序的交换操作介于0和(n-1)次之间。最好情况有序，交换0次；最坏情况，逆序，交换n-1次。<br>选择排序的比较操作为n(n-1)/2次之间。比较次数与初始状态无关，始终是(n-1) + (n-2) + … + 1次。<br>选择排序的赋值操作介于0和3(n-1)次之间。</p>
<p>选择排序中的交换次数比冒泡排序较少，由于交换所需的CPU时间比比较所需的多，n值较小时，选择排序比冒泡排序快。</p>
<p>原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用场合很少。</p>
<hr>
<h2 id="鸡尾酒排序_Cocktail_Shaker_Sort">鸡尾酒排序 Cocktail Shaker Sort</h2><p>鸡尾酒排序，即定向冒泡排序，与冒泡排序的不同之处在于排序是以双向在序列中进行的。<br>冒泡排序是从低到高取比较序列里的每一个元素，而鸡尾酒排序是从低到高然后从高到低。</p>
<p>鸡尾酒排序算法运作如下：（从小到大）</p>
<ol>
<li>比较相邻的元素，如果第一个比第二个大，就交换两个。</li>
<li>对每一对相邻元素作同样的操作，从第一对到最后一对。这步做完之后，最后的元素会是最大的。</li>
<li>从倒数第二个元素开始，朝前比较每对元素，直到第一个元素。如果前一个元素大于后一个元素，则交换两个。这步完成之后，第一个元素将会是最小的。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个和第一个。</li>
<li>持续每次对越来越少的元素重复以上步骤，直到没有任何一对元素需要比较。</li>
</ol>
<p>C++实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cocktail_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j, left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = left; j &lt; right; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">				swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		right--;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = right; j &gt; left; j--)&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])&#123;</span><br><span class="line">				swap(arr[j - <span class="number">1</span>], arr[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		left++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-3">复杂度分析</h4><p>时间复杂度：O(n^2)<br>最优时间复杂度:O(n)<br>平均时间复杂度:O(n^2)</p>
<p>鸡尾酒排序最糟或是平均所花费的次数都是 O(n^2)，但如果序列在一开始已经大部分排序过的话，会接近 O(n)。</p>
<hr>
<h2 id="快速排序_Quicksort">快速排序 Quicksort</h2><p>快速排序又称划分交换排序，使用分治法策略把一个序列分为两个子序列。</p>
<p>快速排序运作如下：</p>
<ol>
<li>从数列中跳出一个元素称为“基准” pivot。</li>
<li>重新排序数列，所有元素比基准值小的摆在基准前，比基准大的放后面（相同的元素可以放任意一边）。该操作结束后，基准就处在数列的中间位置。这个称谓分区partition操作。</li>
<li>递归地recursive把小于基准元素的子序列和大于基准的子序列排序。</li>
</ol>
<p>C++实现<br>迭代法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Range &#123;</span><br><span class="line">	<span class="keyword">int</span> start, end;</span><br><span class="line">	Range(<span class="keyword">int</span> s = <span class="number">0</span>, <span class="keyword">int</span> e = <span class="number">0</span>) &#123;start = s, end = e;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Range r[len]; </span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	r[p++] = Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		Range range = r[--p];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(range.start &gt;= range.end)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		T mid = arr[range.end];</span><br><span class="line">		<span class="keyword">int</span> left = range.start, right = range.end - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)&#123;</span><br><span class="line">				left++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)&#123;</span><br><span class="line">				right--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">std</span>::swap(arr[left], arr[right]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (arr[left] &gt;= arr[range.end])&#123;</span><br><span class="line">			<span class="built_in">std</span>::swap(arr[left], arr[range.end]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		r[p++] = Range(range.start, left - <span class="number">1</span>);</span><br><span class="line">		r[p++] = Range(left + <span class="number">1</span>, range.end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(T arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T mid = arr[end];</span><br><span class="line">	<span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::swap(arr[left], arr[right]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr[left] &gt;= arr[end])&#123;</span><br><span class="line">		<span class="built_in">std</span>::swap(arr[left], arr[end]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		left++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">	quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-4">复杂度分析</h4><p>时间复杂度：O(n^2)<br>最优时间复杂度:O(n<em>log(n))<br>平均时间复杂度:O(n</em>log(n))<br>空间复杂度：根据实现的方式不同而不同</p>
<p>在平均状况下，快速排序n个项目需要O(n<em>log(n))次比较，在最快的情况下需要O(n^2)次比较。事实上，快速排序通常明显比其他O(n</em>log(n))算法更快，因为它的内部循环可以在大部分架构上很有效率地实现。</p>
<hr>
<h2 id="希尔排序_Shellsort">希尔排序 Shellsort</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效版本。<br>希尔排序通过将比较多全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性的朝最终位置前进一大步。然后算法仔取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但到这个时候时，需排序的数据几乎是已排好的了。</p>
<p>将数组列在一个表中并对列排序可以比较好对理解希尔排序。重复这个过程，不过每次用更长的列——更短的行——来进行，最后这个表就只有一列了。<br>例如，假设对下面的组数进行排序：<br>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]<br>如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：<br>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10<br>然后我们对每列进行排序：<br>10 14 73 25 23<br>13 27 94 33 39<br>25 59 94 65 82<br>45<br>将上述四行数字，依序接在一起时我们得到：<br>[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]<br>这时10已经移至正确位置了，然后再以3为步长进行排序：<br>10 14 73<br>25 23 13<br>27 94 33<br>39 25 59<br>94 65 82<br>45<br>排序之后变为：<br>10 14 13<br>25 23 33<br>27 25 59<br>39 65 73<br>45 94 82<br>94<br>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<p>C++实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> gap, i, j;</span><br><span class="line">	T temp;</span><br><span class="line">	<span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">			temp = arr[i];</span><br><span class="line">			<span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">				arr[j + gap] = arr[j];</span><br><span class="line">			arr[j + gap] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-5">复杂度分析</h4><h6 id="步长">步长</h6><p>步长的选择是希尔排序的重要部分。<br>Donald Shell最初建议步长选择为 n／2 并且对步长取半直到为1. 这样的步长表现要比O(n^2)类算法（插入排序）更好，但仍有减少平均时间和最差时间的余地。<br>| 步长序列       | 最快情况下的复杂度|<br>| ————- |:————–:|<br>| n／(2^i)      | O(n^2)         |<br>| 2^k - 1       | O(n^(3/2))    |<br>| 2^i <em> 3^j     | O(n</em>log2(n))  |<br>目前已知的最好步长是由Sedgewick提出的(1, 5, 19, 41, 109…)，该序列的项来自 9 <em> 4^i - 9 </em> 2^i + 1和2^(i+2) * ( 2^(i+2) - 3 ) + 1这两个算式。这样研究也表明：比较时是希尔排序中的主要操作，而不是交换。用这样的步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<hr>
<h2 id="堆排序_Heapsort">堆排序 Heapsort</h2><p>堆排序是利用堆这种数据结构设计的排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点和键值或索引总是小于或大于它的父节点。</p>
<h6 id="堆节点的访问">堆节点的访问</h6><p>通常堆是通过一维数组来实现的：</p>
<ul>
<li>父节点i的左子节点在位置(2*i+1);</li>
<li>父节点i的右子节点在位置(2*i+2);</li>
<li>子节点i的父节点在位置floor((i-1)/2);</li>
</ul>
<h6 id="堆的操作">堆的操作</h6><p>在堆的数据结构中，堆中的最大值总是在根节点。堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整 Max Heapify：将堆堆末端子节点作为调整，使得子节点永远小于父节点</li>
<li>创建最大堆 Build Max Heap：将堆所有数据重新排序</li>
<li>堆排序 Heapsort：移除位在第一个数据的根节点，并做最大堆调整堆递归运算。</li>
</ul>
<p>C++实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dad = start;</span><br><span class="line">	<span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (son &lt;= end) &#123; </span><br><span class="line">		<span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>])&#123;</span><br><span class="line">			son++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (arr[dad] &gt; arr[son])&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			swap(arr[dad], arr[son]);</span><br><span class="line">			dad = son;</span><br><span class="line">			son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">		max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-6">复杂度分析</h4><p>时间复杂度：O(n<em>log(n))<br>最优时间复杂度:O(n</em>log(n))<br>平均时间复杂度:O(n*log(n))<br>空间复杂度：总共O(n)，需要辅助空间O(1)</p>
<hr>
<h2 id="归并排序">归并排序</h2><p>归并排序是创建在归并操作上的一种有效的排序算法，该算法是采用分治法 Divide and Conquer 的一个典型应用。<br>归并操作merge，是指将两个已经排序的序列合并成一个序列的操作。</p>
<p>归并排序运作如下：<br>迭代法</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<p>递归法（假设序列共有n个元素）：</p>
<ol>
<li>将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素</li>
<li>将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</li>
<li>重复步骤2，直到所有元素排序完毕</li>
</ol>
<p>C++实现<br>迭代实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	T* a = arr;</span><br><span class="line">	T* b = <span class="keyword">new</span> T[len];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">			<span class="keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line">			<span class="keyword">int</span> k = low;</span><br><span class="line">			<span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">			<span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)&#123;</span><br><span class="line">				b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (start1 &lt; end1)&#123;</span><br><span class="line">				b[k++] = a[start1++];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (start2 &lt; end2)&#123;</span><br><span class="line">				b[k++] = a[start2++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		T* temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">			b[i] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		b = a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(T arr[], T reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">	<span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">	<span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line"></span><br><span class="line">	merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">	merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k = start;</span><br><span class="line">	<span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)&#123;</span><br><span class="line">		reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start1 &lt;= end1)&#123;</span><br><span class="line">		reg[k++] = arr[start1++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start2 &lt;= end2)&#123;</span><br><span class="line">		reg[k++] = arr[start2++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = start; k &lt;= end; k++)&#123;</span><br><span class="line">		arr[k] = reg[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	T reg[len];</span><br><span class="line">	merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-7">复杂度分析</h4><p>时间复杂度：O(n<em>log(n))<br>最优时间复杂度:O(n)<br>平均时间复杂度:O(n</em>log(n))<br>空间复杂度:O(n)</p>
<hr>
<h2 id="简单比较">简单比较</h2><table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">数据对象</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">时间复杂度(平均/最坏)</th>
<th style="text-align:center">额外空间复杂度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td>（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。</td>
<td></td>
</tr>
<tr>
<td>选择排序</td>
<td style="text-align:center">数组/链表</td>
<td style="text-align:center">N/Y</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td>（有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td style="text-align:center">数组/链表</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td>（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">N</td>
<td style="text-align:center">O(n*log(n))</td>
<td style="text-align:center">O(1)</td>
<td>（最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">数组/链表</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">O(n<em>log(n))/O(n</em>log2(n))</td>
<td style="text-align:center">O(1)/O(n)+O(\log n)(如果不是从下到上),O(1)</td>
<td>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。可从上到下或从下到上进行。</td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">N</td>
<td style="text-align:center">O(n*log(n))/O(n^2)</td>
<td style="text-align:center">O(log(n))</td>
<td>（小数，基准元素，大数）。在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</td>
<td></td>
</tr>
<tr>
<td>希尔排序</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">N</td>
<td style="text-align:center">O(n*log2(n))/O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td>每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。</td>
<td></td>
</tr>
<tr>
<td>计数排序</td>
<td style="text-align:center">数组/链表</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">O(n+m)</td>
<td style="text-align:center">O(n+m)</td>
<td>统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</td>
<td></td>
</tr>
<tr>
<td>桶排序</td>
<td style="text-align:center">数组/链表</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">O(m)</td>
<td style="text-align:center">O(m)</td>
<td>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">数组/链表</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">O(k*n)/O(n^2)</td>
<td style="text-align:center"></td>
<td>一种多关键字的排序算法，可用桶排序实现。</td>
<td></td>
</tr>
</tbody>
</table>
<p>⚠️排序算法的稳定性：稳定排序算法会让相等键值的记录维持原有的相对次序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2016/02/sorting-algorithms/" data-id="cj6khx4na00022xpsyxo4q9v7" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2016/02/sorting-algorithms/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Homebrew-install-failed" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/Homebrew-install-failed/" class="article-date">
  <time datetime="2015-11-29T16:37:21.000Z" itemprop="datePublished">11-30-2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/Homebrew-install-failed/">Homebrew安装失败</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>按照 <a href="http://brew.sh/index.html" target="_blank" rel="external">http://brew.sh/index.html</a> 安装Homebrew 执行如下命令：<br>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>
<p>然后失败：<br>fatal: unable to access ‘<a href="https://github.com/Homebrew/homebrew/" target="_blank" rel="external">https://github.com/Homebrew/homebrew/</a>‘: SSLRead() return error -9806<br>Failed during: git fetch origin master:refs/remotes/origin/master -n –depth=1</p>
<p>google一圈，这个问题似乎和我的一致<br><a href="http://stackoverflow.com/questions/26461966/osx-10-10-curl-post-to-https-url-gives-sslread-error" target="_blank" rel="external">http://stackoverflow.com/questions/26461966/osx-10-10-curl-post-to-https-url-gives-sslread-error</a><br>需要安装使用openssl的curl</p>
<p>遂先安装openssl<br>获取openssl代码，<a href="https://wiki.openssl.org/index.php/Use_of_Git" target="_blank" rel="external">https://wiki.openssl.org/index.php/Use_of_Git</a><br>git clone <a href="https://github.com/openssl/openssl.git" target="_blank" rel="external">https://github.com/openssl/openssl.git</a></p>
<p>编译安装，<a href="https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac" target="_blank" rel="external">https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac</a><br>./Configure darwin64-x86_64-cc enable-ec_nistp_64_gcc_128  no-ssl3 no-comp<br>make<br>sudo make install</p>
<p>获取curl代码,<a href="http://curl.haxx.se/download/curl-7.45.0.tar.bz2" target="_blank" rel="external">http://curl.haxx.se/download/curl-7.45.0.tar.bz2</a><br>安装，<a href="http://curl.haxx.se/docs/install.html" target="_blank" rel="external">http://curl.haxx.se/docs/install.html</a><br>./configure –with-ssl=/usr/local/ssl<br>make<br>编译报错：<br>vtls/openssl.c:2349:13: error: incomplete definition of type ‘struct x509_st’<br>    cinf = x-&gt;cert_info;<br>           ~^<br>/usr/local/ssl/include/openssl/ossl_typ.h:154:16: note: forward declaration of ‘struct x509_st’<br>typedef struct x509_st X509;<br>               ^<br>…</p>
<p>再google，发现这是个已知问题，<a href="https://github.com/bagder/curl/issues/491" target="_blank" rel="external">https://github.com/bagder/curl/issues/491</a><br>subscribe那个issues。</p>
<p>作此文纪录，先睡觉了。  </p>
<p>12/13/2015 更新<br>收到issue 491＃的邮件通知说编译问题已经解决了。<br><a href="https://github.com/bagder/curl/commit/7f683b0ea87ed158eb4bd22cdd1f26eb901a97d0" target="_blank" rel="external">https://github.com/bagder/curl/commit/7f683b0ea87ed158eb4bd22cdd1f26eb901a97d0</a><br>该commit解决了curl与openssl 9446daac5b7be3210e9c5d80c3d95309d946ee38 版本编译不过的问题。</p>
<p>于是我更新了最新的curl代码<br>git clone <a href="https://github.com/bagder/curl.git" target="_blank" rel="external">https://github.com/bagder/curl.git</a><br>./buildconf<br>./configure –with-ssl=/usr/local/ssl/<br>make<br>make install</p>
<p>当再执行curl时<br>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”<br>curl: (35) error:1416F086:SSL routines:tls_process_server_certificate:certificate verify failed</p>
<p>这个google也没找到原因了。 我想了下，可能是最新的openssl的问题。于是去openssl下载了一个release版本，<a href="https://www.openssl.org/source/openssl-1.0.1q.tar.gz，故意选择了1.1.0之前的版本。解压编译安装。发现该版本如果配置为“no-ssl3" target="_blank" rel="external">https://www.openssl.org/source/openssl-1.0.1q.tar.gz，故意选择了1.1.0之前的版本。解压编译安装。发现该版本如果配置为“no-ssl3</a> no-comp”也会有编译问题，索性直接“./Configure darwin64-x86_64-cc enable-ec_nistp_64_gcc_128”，然后编译安装一路通畅。</p>
<p>然后重新编译安装了7.45.0版本的curl，安装成功。尝试运行：<br>curl <a href="https://google.com" target="_blank" rel="external">https://google.com</a><br>curl: (60) SSL certificate problem: unable to get local issuer certificate<br>More details here: <a href="http://curl.haxx.se/docs/sslcerts.html" target="_blank" rel="external">http://curl.haxx.se/docs/sslcerts.html</a></p>
<p>curl performs SSL certificate verification by default, using a “bundle”<br> of Certificate Authority (CA) public keys (CA certs). If the default<br> bundle file isn’t adequate, you can specify an alternate file<br> using the –cacert option.<br>If this HTTPS server uses a certificate signed by a CA represented in<br> the bundle, the certificate verification probably failed due to a<br> problem with the certificate (it might be expired, or the name might<br> not match the domain name in the URL).<br>If you’d like to turn off curl’s verification of the certificate, use<br> the -k (or –insecure) option.</p>
<p>这里说本地CA证书有问题，参考<a href="http://curl.haxx.se/docs/sslcerts.html，从http://curl.haxx.se/docs/caextract.html下载了CA证书，然后" target="_blank" rel="external">http://curl.haxx.se/docs/sslcerts.html，从http://curl.haxx.se/docs/caextract.html下载了CA证书，然后</a><br>export CURL_CA_BUNDLE=”/usr/local/etc/pki/cacert.pem”</p>
<p>然后执行<br>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”<br>终于<br>…<br>==&gt; Installation successful!<br>==&gt; Next steps<br>Run <code>brew help</code> to get started</p>
<p>上面的本地CA证书，可以通过–cacert来配置，如下<br>curl –cacert /usr/local/etc/pki/cacert.pem  <a href="https://cn.bing.com" target="_blank" rel="external">https://cn.bing.com</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2015/11/Homebrew-install-failed/" data-id="cj6khx4ny000m2xpswbx9ktsm" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2015/11/Homebrew-install-failed/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-about-google-play-return-to-china" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/about-google-play-return-to-china/" class="article-date">
  <time datetime="2015-10-30T14:03:19.000Z" itemprop="datePublished">10-30-2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/about-google-play-return-to-china/">关于Google Play商店入华的想法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在写标题的时候，我就在纠结是写Play商店入华还是返华。2010年初Google宣布退出中国市场的时候，Google Play还叫Android Market。当时的安卓版本还在2.0/2.1，国内还没有安卓手机上市，市场上只有少量的水货安卓机————那个都是预置了Android Market的，也都可以正常使用的。</p>
<p>看那个是时候的中国智能机市场，iPhone（3G／3GS）刚被联通刚引入不久，还没有飞入寻常百姓家；黑莓／Palm有一批死忠，但始终小众；噢，那时还是诺基亚塞班在一统天下。</p>
<p>也就是Google退出中国的2010年，安卓在中国开始萌芽发展，中华酷联都开始逐步推出自己的安卓智能机，小米也开始做MIUI了。好像那个时候有些国产手机就没有预置Android market了。我记得我2010年入的一款华为安卓机还是自己刷的GMS。但那个时候，刷上去就可以用。虽然Google也宣布退出中国，但Google服务基本还可以正常用。当然，Android Market并没有单独设中国区，也不能用购买付费应用。</p>
<p>所以我认为，Play商店从来没有真正进入过中国，所以最后还是写了“入华”。</p>
<p>再后来，Android Market变成了Google Play，我们在墙内访问Google也越来越难。我也记不清具体是从什么时候开始，我必须要连上VPN才能上Play了。</p>
<p>就这样，慢慢的，墙内用的安卓，已经完全不是那个Google的安卓了。如果不连VPN，Google服务基本是完全废了。也就是这个原因，我逐渐转到乔帮主门下了，毕竟在墙内用iOS的体验，和在墙外用iOS的体验没有太大差别。另外，iOS app store的账户归属地是注册时就确定了，也就是说，我注册了一个美区账号，我不管在哪登陆，我进去的都是美区市场，这个对我来说真是极好的呀。想我在安卓上，为了上美区的Play，可是要清除Play缓存，关掉移动网络，连接美帝VPN，然后才有可能进到原汁原味的美区Play。</p>
<p>我以为我在墙内再也用不上安卓了————没有Play，没有Google的安卓还是安卓么？</p>
<p>但从去年下半年开始，坊间一直在传Google Play商店将要进入中国，并认为Play商店是Google返华的第一步。</p>
<p>去年同时传的还有一条消息就是将会有一家中国厂商代工NEXUS，同样也认为这是Google回归的重要事件。当然，现在这条传闻已经成真了，华为作为第一家中国厂商代工了NEXUS 6P，但同时华为也表示NEXUS 6P不会在中国上市。一直期待着国行NEXUS的可以童鞋可以暂时守住腰包了。就目前来看，我不认为华为代工的NEXUS 6P对Google返华或者Play入华产生了很大影响————当然，这只是我们目前看到的。</p>
<p>这两天又被Play入华的消息刷屏了，老是炒来炒去，那我也来说说我的想法。</p>
<p>作为一枚Google忠实用户，我当然希望Google返华，但是我希望的是那个不作恶的Google。<br>我也希望Google Play商店进入中国来提升一下中国应用分发的质量，但我个人并不看到Play入华。</p>
<p>首先，Google Play进入中国势必要接受政府审查，为了过审，Google势必独立出一个Play中国区出来。那个Play一定会是有中国特色的。这个倒不是关键，关键的是，用户登录Play的时候，会进去到哪个区。Google账号没有像Apple ID一样分区。那我担心到时候，只要登录的IP在中国，或者手机运营商是中国区的，或者手机位置显示在中国，都强行进去中国区。这样我基本就没有办法逃离这里区，几乎不可能获取美区的一些优秀APP了。这是我个人最不愿意看到的，我想这应该也是大部分现在翻墙上Play的人不愿意的。如果真的的这样，个人觉得Play很可能连我们这一批Play死忠都要失去。</p>
<p>为什么说是“连…”也要失去呢？因为我也不看到Google Play真的打开中国市场。Google退出中国多年，很多人已经淡忘这家伟大的公司，有很多人不知道Google与安卓的关系，更有人（还是IT从业人员）居然不知道小米是安卓系统的。虽然安卓手机在中国遍地开花，但大众对安卓的认知度并不高，大家都在说我用华为手机，用小米手机，用OPPO，用三星…同样，所有在中国销售的手机，都会预置自己厂商的应用市场，另外还有豌豆荚，应用宝，安智等一大票第三方市场，而百度，360等也是虎视眈眈，更有专注盗版共享软件的应用市场。所以，在Google和安卓认知度都不高的地盘，在手机上已经堆了好几个应用市场之后，再多出来的一个Play又能怎么样呢？肯定会有人说Play也会出厂预置。我觉得除非出厂只预置Play，而把厂家自己的应用商店删掉，这样Play作为出厂的默认应用商店的确有可能获得一部分流量。但手机厂商会同意这么干么？个人觉得这个要看Google能出什么价了，手机厂商应该都不会轻易妥协。</p>
<p>另外，关于付费应用。虽然苹果帮忙把应用付费的习惯培养了几年，现在iOS app store中国收益也认为乐观，但我不觉得Play可以很好的复制app store。根据我的了解，大部分iOS用户愿意掏钱，是因为装盗版应用的难度较大，所以选择付费。但回到安卓，当前的应用机制使得安装盗版应用很方便。就像今天中午听到的“有盗版的可以用，谁还付费呀？”。这应该是当前大部分人的心态。</p>
<p>综上，我认为，Play入华，靠不了情怀，与本地商店免费肉搏不占优势，付费的要先防好盗版的。前面的路还长…</p>
<p>最后，希望不作恶的Google最后可以回来，回到这个“有朋自远方来，不亦乐乎”的国度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2015/10/about-google-play-return-to-china/" data-id="cj6khx4nw000l2xpsoz6la7vn" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2015/10/about-google-play-return-to-china/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-reading_Asserton_of_Zhou_Hongwei_My_Own_Methodology_on_Internet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/reading_Asserton_of_Zhou_Hongwei_My_Own_Methodology_on_Internet/" class="article-date">
  <time datetime="2015-10-23T12:06:13.000Z" itemprop="datePublished">10-23-2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/reading_Asserton_of_Zhou_Hongwei_My_Own_Methodology_on_Internet/">在传统设备厂商看周鸿祎的互联网方法论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今年夏天，公司建了个图书角，某日过去发现一本《周鸿祎自述——我的互联网方法论》，封面上写是周鸿祎迄今为止唯一著作，加上“互联网”“方法论”的字眼，让我毫无犹豫的把这本书借了回来。借回来之后，刚开始几天还看的挺勤的，每天晚上下班回来都翻几页，基本是作为睡前读物在看。后来因为脖子的关系，然后十一放假，接着又狂加班，这本书就被落下了。最近有人提醒说书要还了，我才想起来，还有一点没有看完。今天终于休息，有点时间把前面剩下的看完了，然后趁热写点感想。一来记下自己现在的想法，二来，让新买的电脑用起来。</p>
<p>说起周鸿祎，我们这一代人肯定先想到就是360.09年，终于攒了一台属于我自己的电脑之后，第一个（至少是第一批）安装的应用就是360安全卫士。但后来觉得360安全卫士越来越臃肿，也听信了网络上一些关于360不好的传闻，等到10年3Q大战的时候，我电脑上已经没有360的产品了。因为360的关系，对周鸿祎这个印象也不是很好——虽然我对这个人基本一无所知。</p>
<p>后来12年的时候，读到林锐博士的《我的大学十年》，中间写道当年林锐博士拿着自己认为写的很不错的代码去找周鸿祎，结果被周鸿祎指出漏洞百出，顿时觉得周鸿祎这个似乎技术很厉害。</p>
<p>12年，也正是移动互联网开始爆发的年代，很快，我突然发现周围很多人的手机上也装了360手机卫士。我实在不知道在没越狱的iphone 4S上装上360有什么意义。而在11年多时候，我就发现同学中基本都在用360浏览器。犹如醍醐灌顶：这家原来只做安全卫士，只说“您已击败全国x％电脑的免费杀毒软件公司，自身已经病毒式扩张和发展了。</p>
<p>回到《我的互联网方法论》这本书，这本书基本也是讲周鸿祎创建和发展360公司的一些经验，总结出来就成了周鸿祎的互联网方法论，还洋洋洒洒写了十五万字。整本书下来，我觉得他的互联网方法论主要在强调三点：用户，免费和体验。</p>
<p>用户，周鸿祎在书中花了一节来讲述“是用户，而不是客户”。这个和某司强调的“以客户为中心”有较大区别，这也许正是一个互联网公司和一个传统设备公司的距离。我个人比较赞同周鸿祎的观点。用户是使用你产品的人，而客户是给你掏钱的人。当然，这两拨人中可能有很大一部分重合的。我们往往更在乎给你钱的人——拿人家的手短嘛。而真正感知我们产品的还是用户。只有用户用的爽，才会有客户给你掏钱——对于互联网产品，尤其是这样。</p>
<p>这里就有了一个问题，怎样让用户用的爽？这就是第二点，体验。书中把超出预期体验叫用户体验。体验源于需求，帮用户真正解决问题，然后要聚焦，注重细节，追求极致。这似乎也是我们说到体验常谈到的点。也是，总结起来永远是这么几点，但就是做不好。我参加好几次我们公司手机的beta测试，以前提的体验类的问题基本都是石沉大海的，现在还是进步了，一般还是有人来跟踪，但一般得到大结论都是“规格就是这样的”“XXX产品就是这样的”“平台不支持”。甚至还有专门负责体验的部门同事来找我提意见，我说了几天，然后那哥们儿苦笑着说其实我们开始设计的不是这个样子的，但不知道为啥被产品做成这样了。。。</p>
<p>最后一个，也是书中讲的最多的（个人感觉是最多的，没有统计），就是免费。产品用户从哪来？除了体验，另一个利器就是免费。个人觉得周鸿祎对免费这种商业模式的理解是很深刻的——这也许就是360免费杀毒以及整个360成功的关键。周鸿祎认为互联网数字化产品就该免费，将来硬件也会免费。个人目前不完全同意书中的观点。我认为这个要分市场。对于大众市场，免费给大众，然后提供增值服务，这个是可以的。但对于小众产品，这个可能就需要慎重考虑了。另外，关于硬件免费，当然就是需要服务收费，我认为当前的市场还不成熟，未来可能会这样，但我不知道了。</p>
<p>最后，书中有一个地方我觉得好像不对。书中说惠普做了一款平板电脑，卖399美元卖了几年没卖出几台，后来99美元清仓，不到一天就把全美的库存就清完了。这里说的这款平板应该就是TouchPad吧？这款平板是2011年2月9号发布的，11年7月1号以399美元在美国发售，11年8月19号惠普宣布停止生产并且99美元（16GB的，32GB的是149美元）清仓的。这货根本没有卖几年，而是只有49天！另外，当时清仓甩卖的时候，的确有人排队抢购，但我也不认为不到一天就把北美的库存清完了，因为2013年的时候，我在美亚上看到还有存货在卖。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2015/10/reading_Asserton_of_Zhou_Hongwei_My_Own_Methodology_on_Internet/" data-id="cj6khx4nc00032xps2aiizg1y" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2015/10/reading_Asserton_of_Zhou_Hongwei_My_Own_Methodology_on_Internet/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-about-pseudo-random-number-generators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/about-pseudo-random-number-generators/" class="article-date">
  <time datetime="2015-08-22T13:06:42.000Z" itemprop="datePublished">08-22-2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/about-pseudo-random-number-generators/">关于（伪）随机数生成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文描述现代密码学体系中最重要的组件之一，通常也被认为是最难描述的组件：随机数生成器</p>
<p>什么样的是随机数？<br>我见过的最通俗地对随机数的描述是这样的：<br>一串数字，如果没有比它更短的可以描述它的形式的程序，那么它就是随机的。</p>
<p>随机数从哪来？如何生成？<br>我们认为，一个完美的抛硬币是一个真随机的过程——假设硬币是中心对称，且在空中是平稳飞行。还有比如半导体噪声，元素的放射性衰变，这样都认为是真随机的过程。如果把物理过程的输出记录下来作为随机数，那这有了个真随机数生成器。</p>
<p>真随机数生成器发生的随机数可以认为是完全不可预测，这正是密码学需要的最佳选择。但是真随机数生成器一般效率都比较低，不能满足使用需求。所以就有了伪随机数生成器（Pseudo Random Number Generator, PRNG），或者叫做确定性随机位生成器（Deterministic Random Bit Generator, NIST, DRBG）。这类随机数发生器一般是一个确定性算法，即按照一种准确的规则集作为软件或硬件的算法，比如从一个初始种子值开始通过各种计算得到序列。一个广泛使用的例子就是ANSI C中的rand()函数，它的实现模型为：<br>S0 = 12345<br>S(n+1) = 1103515245S(n) + 12345 mod 2xp31, n=0,1…</p>
<p>对PRNG的一个一般要求就是必须拥有良好的统计属性，意味着它的输出近乎与真随机序列相同。有很多数学测试，如卡方校验，可以验证PRNG的统计行为。一般工程学上使用的PRNG满足此要求即可。</p>
<p>然后密码安全的伪随机数发生器（CSPRNG）则还要求不可预测性，即CSPRNG应该满足   </p>
<ol>
<li>给定密钥序列中n个连续位，不存在一个时间复杂度位多项式的算法使得成功预测下一位S(n+1)的概率超过50%   </li>
<li>给出密钥S(i),S(i+1)…S(i+n-1)，计算任何之前的位S(i-1), S(i-2)…在计算上是不可行的。</li>
</ol>
<p>NIST SP 800-90从提出了3个随机函数：<br>//TODO</p>
<p>由于PRNG的算法一定是确定性的，为了让PRNG确定性状态的某些部分对外来的观察者是不可预测的，所以需要某些外来的源用熵来设置种子。</p>
<p>熵，entroy，源于希腊文，意为变化。熵是一个可以观察的事件中对不可确定性的一种度量，并且特别地以位为单位来表示，因为经常以二进制决策图来描述它。</p>
<p><a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documentation_software.html" target="_blank" rel="external">NIST: Random Number Generators</a><br><a href="http://crypto.stackexchange.com/questions/19861/interpretation-of-the-results-of-nist-pnrg-suite" target="_blank" rel="external">stackexchange: Interpretation of the results of NIST (p)NRG suite</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2015/08/about-pseudo-random-number-generators/" data-id="cj6khx4ns000h2xpstksbli7a" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2015/08/about-pseudo-random-number-generators/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/密码学/">密码学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随机数/">随机数</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-programmer-competency-matrix" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/programmer-competency-matrix/" class="article-date">
  <time datetime="2015-07-01T13:40:36.000Z" itemprop="datePublished">07-01-2015</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/programmer-competency-matrix/">程序员能力矩阵</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="计算机科学">计算机科学</h2><table>
<thead>
<tr>
<th>0</th>
<th>2n (Level 0)</th>
<th>n^2 (Level 1)</th>
<th>n (Level 2)</th>
<th>log(n) (Level 3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据结构</td>
<td>不知道数组和链表的差异</td>
<td>能够解释和使用数组，链表，字典等，并且能够用于实际的编程任务。</td>
<td>了解基本数据结构时间和空间的折中，比如数组vs 链表，能够解释如何实现哈希表和处理冲突，了解优先队列及其实现。</td>
<td>高等的数据结构的知识，比如B-树、二项堆、斐波那契堆、AVL树、红黑树、伸展树、跳跃表以及前缀树等。</td>
</tr>
<tr>
<td>算法</td>
<td>不能够找出一个数组各数的平均值(这令人难以置信，但是我的确在应聘者中遇到过)</td>
<td>基本的排序，搜索和数据的遍历和检索算法。</td>
<td>树，图，简单的贪婪算法和分而治之算法，能够适度了解矩阵该层的含义。</td>
<td>能够辨识和编写动态规划方案，良好的图算法知识，良好的数值估算的知识，能够辨别NP问题等。</td>
</tr>
<tr>
<td>编程体系</td>
<td>不知道何为编译器、链接器和解释器。</td>
<td>对编译器、链接器、解释器有基本的了解。知道什么是汇编代码以及在硬件层如何工作。有一些虚拟内存和分页知识。</td>
<td>了解内核模式vs用户模式,多线程，同步原语以及它们如何实现，能够阅读汇编代码。了解网络如何工作，了解网络协议和socket级别编程。</td>
<td>了解整个程序堆栈、硬件(CPU+内存+中断+微码)、二进制代码、汇编、静态和动态链接、编码、解释、JIT（just-in-time）编译、内存碎片回收、堆、栈、存储器编址…</td>
</tr>
</tbody>
</table>
<h2 id="软件工程">软件工程</h2><table>
<thead>
<tr>
<th>0</th>
<th>2n (Level 0)</th>
<th>n^2 (Level 1)</th>
<th>n (Level 2)</th>
<th>log(n) (Level 3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>源码版本控制</td>
<td>通过日期备份文件夹</td>
<td>VSS和初级的CVS/SVN用户</td>
<td>熟练地使用CVS和SVN特性。知道如何分支和归并，使用程序库补丁安装特性等</td>
<td>有分布式VCS系统的知识。尝试过Bzr/Mercurial/Darcs/Git</td>
</tr>
<tr>
<td>自动化编译</td>
<td>只知道在IDE下编译</td>
<td>知道如何编译在命令行下编译系统</td>
<td>能够安装一个脚本构建基本的系统</td>
<td>能够安装一个脚本来构建系统并且归档，安装程序，生成发布记录和给源码控制中的代码分配标签。</td>
</tr>
<tr>
<td>自动化测试</td>
<td>认为所有的测试都是测试员的工作。</td>
<td>能够编写自动化的单元测试，能够为正在编写的代码提出良好的测试用例。</td>
<td>按照TDD （Test Driven Development）方式编写代码。</td>
<td>了解并且能够有效自动化安装，载入/性能和UI测试</td>
</tr>
</tbody>
</table>
<h2 id="程序设计">程序设计</h2><table>
<thead>
<tr>
<th>0</th>
<th>2n (Level 0)</th>
<th>n^2 (Level 1)</th>
<th>n (Level 2)</th>
<th>log(n) (Level 3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>问题分解</td>
<td>只有直线式的代码，通过复制粘贴来复用</td>
<td>能够把问题分散到多个函数中</td>
<td>能够想出可复用的函数/对象来解决大题的问题</td>
<td>使用适宜的数据结构和算法，写出通用的/面向对象的代码来封装问题的易改变的层面。</td>
</tr>
<tr>
<td>系统分解</td>
<td>N想不出比单一的文件/类更好的层面</td>
<td>如果不在同一平台或没采用相同的技术，能够把问题空间和设计方案分解。</td>
<td>能够设计跨技术/平台的系统。</td>
<td>能够在多个产品线和与外部体系一体化中虚拟化和设计复制的系统。同时也能够设计支持系统监视、报告、故障恢复等。</td>
</tr>
<tr>
<td>交流</td>
<td>不能向同伴表达想法/主意。匮乏拼写和语法的能力。</td>
<td>同伴能了解你在说什么。有良好的拼写和语法能力。</td>
<td>能够和同伴进行高效的交流</td>
<td>能够使用清晰的方式了解和交流想法/设计/主意/细则，能适应每种环境的交流</td>
</tr>
<tr>
<td>同一文件中代码组织</td>
<td>同一文件中组织没有依据</td>
<td>按照逻辑性或者易接近的方法</td>
<td>代码分块和对于其他源文件来说是易于是释,引用其他源文件时有良好的注释</td>
<td>文档头部有许可声明，总结，良好的注释，一致的空格缩进。文档外观美观。</td>
</tr>
<tr>
<td>0</td>
<td>2n (Level 0)</td>
<td>n^2 (Level 1)</td>
<td>n (Level 2)</td>
<td>log(n) (Level 3)</td>
</tr>
<tr>
<td>跨文件代码组织</td>
<td>没够想过给代码跨文件组织</td>
<td>相关文件按文件夹分组</td>
<td>每个物理文件都有独立的目的，比如一个类的定义，一个特性的实现等。</td>
<td>代码在物理层组织紧密，在文件名上与设计和外观相匹配，可以通过文件分布方式洞察设计理念。</td>
</tr>
<tr>
<td>源码树组织</td>
<td>一切都放在一个文件夹内</td>
<td>初步地将代码分散进对应逻辑的文件夹。</td>
<td>没有循环依赖，二进制文件，库，文档，构建，第三方的代码都组织进合适的文件夹内。</td>
<td>源码树的物理布局与逻辑层次、组织方式相匹配。可以通过目录名称和组织方式洞察设计理念。</td>
</tr>
<tr>
<td>代码可读性</td>
<td>单音节的名称 （在国内应该是那些类似用汉语拼音命名的习惯）</td>
<td>对文件、变量、类、方法等，有良好的命名。</td>
<td>没有长函数、注释解释不常规的代码，bug修复,代码假设。</td>
<td>代码假设验证使用断言，自然的代码流，没有深层嵌套的条件和方法</td>
</tr>
<tr>
<td>防御性编码</td>
<td>不知道这个概念</td>
<td>检查代码中所有的参数，对关键的假设进行断言</td>
<td>确保检查了返回值和使代码失败的异常。</td>
<td>有自己的库来帮助防御性编程、编写单元测试模拟故障</td>
</tr>
<tr>
<td>0</td>
<td>2n (Level 0)</td>
<td>n^2 (Level 1)</td>
<td>n (Level 2)</td>
<td>log(n) (Level 3)</td>
</tr>
<tr>
<td>错误处理</td>
<td>只给乐观的情形编码</td>
<td>基本的代码错误处理，抛出异常/生成错误</td>
<td>确保错误/异常留在程序中有良好的状态，资源，连接，内存都有被合适的清理。</td>
<td>在编码之前察觉可能出现的异常，在代码的所有层次中维持一致性的异常处理策略，提出整个系统的错误处理准则。</td>
</tr>
<tr>
<td>IDE</td>
<td>IDE大部分用来进行文本编辑</td>
<td>了解其周围的接口，能够高效地通过菜单来使用IDE</td>
<td>了解最常操作的键盘快捷键</td>
<td>编写自定义宏</td>
</tr>
<tr>
<td>API</td>
<td>需要频繁地查阅文档</td>
<td>把最频繁使用的API记在脑子里</td>
<td>广阔且深入的API知识。</td>
<td>为了使实际任务中常用API使用更加便捷，编写过API的上层库，填补API之间的缺口。</td>
</tr>
<tr>
<td>框架</td>
<td>没有使用过主平台外的任何框架</td>
<td>听过但没用过平台下流行的可用框架</td>
<td>在专业的职位中使用过一个以上的框架，通晓各框架的特色。</td>
<td>某框架的作者</td>
</tr>
<tr>
<td>0</td>
<td>2n (Level 0)</td>
<td>n^2 (Level 1)</td>
<td>n (Level 2)</td>
<td>log(n) (Level 3)</td>
</tr>
<tr>
<td>需求分析</td>
<td>接受给定的需求和代码规格</td>
<td>能对规格的遗漏提出疑问</td>
<td>了解全面情况，提出需要被规格化的整体范围。</td>
<td>能够提出更好的可选方案，根据经验的浮现给出需求</td>
</tr>
<tr>
<td>脚本</td>
<td>不具备脚本工具的知识</td>
<td>批处理文件/shell脚本</td>
<td>Perl/Python/Ruby/VBScript/Powershell</td>
<td>写过并且发表过可重用的代码</td>
</tr>
<tr>
<td>数据库</td>
<td>认为Excel就是数据库</td>
<td>知道基本的数据库概念，规范化、ACID（原子性Atomicity、一致性Consistency、隔离性Isolation、持久性Durability）、事务化，能够写简单的select语句</td>
<td>能够牢记在运行时必要查询中设计良好的规范化数据库模式， 精通用户视图，存储过程，触发器和用户定义类型。知道聚集与非聚集索引之间的差异。精通使用ORM（Object Relational Mapping对象关系映射）工具</td>
<td>能做基本的数据库管理，性能优化，索引优化，编写高级的select查询，能够使用相关sql来替换游标，理解数据内部的存储，了解如何镜像、复制数据库。知道两段数据提交如何工作</td>
</tr>
</tbody>
</table>
<h2 id="经验">经验</h2><table>
<thead>
<tr>
<th>0</th>
<th>2n (Level 0)</th>
<th>n^2 (Level 1)</th>
<th>n (Level 2)</th>
<th>log(n) (Level 3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>专业语言经验</td>
<td>命令式语言和面向对象语言</td>
<td>命令式语言,面向对象语言和说明型语言(SQL),如果了解静态类型vs动态类型，弱类型vs强类型则有加分</td>
<td>函数式语言,如果了解延缓求值，局部套用函数，延续则有加分</td>
<td>并发语言(Erlang, Oz) 逻辑语言(Prolog)</td>
</tr>
<tr>
<td>专业平台经验</td>
<td>1</td>
<td>2-3</td>
<td>4-5</td>
<td>6+</td>
</tr>
<tr>
<td>专业经验年龄</td>
<td>1</td>
<td>2-5</td>
<td>6-9</td>
<td>10+</td>
</tr>
<tr>
<td>领域知识</td>
<td>没有该领域的知识</td>
<td>在该领域中曾经至少为一个产品工作过</td>
<td>在同一领域中为多个产品工作过</td>
<td>领域专家。在该领域设计和实现数种产品/方案。精通该领域使用的标准条款和协议</td>
</tr>
</tbody>
</table>
<h2 id="学识">学识</h2><table>
<thead>
<tr>
<th>0</th>
<th>2n (Level 0)</th>
<th>n^2 (Level 1)</th>
<th>n (Level 2)</th>
<th>log(n) (Level 3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>工具知识</td>
<td>仅限于主要的IDE(VS.Net, Eclipse等)</td>
<td>知道一些流行和标准工具的备选方案</td>
<td>对编辑器、调试器、IDE、开源的备选方案有很好的了解。比如某人了解大多数Scott Hanselman的威力工具列表中的工具，使用过ORM工具。</td>
<td>实际地编写过工具和脚本，如果这些被发布则有加分</td>
</tr>
<tr>
<td>语言接触</td>
<td>命令式语言和面向对象语言</td>
<td>命令式语言、面向对象语言和说明型语言(SQL),如果了解静态类型vs动态类型、弱类型vs强类型则有加分</td>
<td>函数式语言,如果了解延缓求值、局部套用函数、continuations （源于scheme中的一种高级控制结构）则有加分</td>
<td>并发语言(Erlang, Oz) 逻辑语言(Prolog)</td>
</tr>
<tr>
<td>代码库知识</td>
<td>从来没有查询过代码库</td>
<td>基本的代码层知识，了解如果构建系统</td>
<td>良好的代码库工作知识，实现过几次bug修复或者完成了一些细小的特性</td>
<td>实现了代码库中多个大型特性，能够轻松地将多数特性的需求变更具体化，从容地处理bug修复。</td>
</tr>
<tr>
<td>下一代技术知识</td>
<td>从来没听说过即将到来的技术</td>
<td>听说过某领域即将到来的技术</td>
<td>下载过alpha preview/CTP/beta版本，并且读过一些文章和手册</td>
<td>试用过预览版而且实际地构建过某物，如果共享给其他人的话则有加分</td>
</tr>
<tr>
<td>0</td>
<td>2n (Level 0)</td>
<td>n^2 (Level 1)</td>
<td>n (Level 2)</td>
<td>log(n) (Level 3)</td>
</tr>
<tr>
<td>平台内部</td>
<td>对平台内部毫无所知</td>
<td>有平台基本的内部工作的知识</td>
<td>深度的平台内部知识，能够设想平台如何将程序转换成可执行代码。</td>
<td>编写过增强平台或者为其平台内部提供信息的工具。比如，反汇编工具，反编译工具，调试工具等。</td>
</tr>
<tr>
<td>书籍</td>
<td>菜鸟系列，21天系列，24小时系列，蠢货系列…</td>
<td>《代码大全》，《别让我思考》, 《精通正则表达式》</td>
<td>《设计模式》，《人件》，《代码珠玑》，《算法设计手册》，《程序员修炼之道》，《人月神话》</td>
<td>《计算机程序设计与解释》，《事务处理:概念与技术》，《计算机程序设计模型》，《计算机程序设计艺术》，《数据库系统导论》 C.J Date版，《Thinking Forth》 ，《Little Schemer》（没找到其中译本）</td>
</tr>
<tr>
<td>博客</td>
<td>听过但是从来抽不出空去接触</td>
<td>阅读一些科技/编程/软件工程的博客，并且经常的收听一些播客</td>
<td>维护一些博客的链接，收集博主分享的有用的文章和工具</td>
<td>维护一个在编程方面，分享有个人见解和思考的博客</td>
</tr>
</tbody>
</table>
<p><a href="http://static.icybear.net/%5BCN%5DProgrammer%20competency%20matrix.htm" target="_blank" rel="external">[译文]程序员能力矩阵 Programmer Competency Matrix</a><br><a href="http://sijinjoseph.com/programmer-competency-matrix/" target="_blank" rel="external">Programmer Competency Matrix</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://brightonzhang.com/2015/07/programmer-competency-matrix/" data-id="cj6khx4nd00042xpsfbg3vnzc" class="article-share-link">Share</a>
      
        <a href="http://brightonzhang.com/2015/07/programmer-competency-matrix/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/密码学/">密码学</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/比特币/">比特币</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随机数/">随机数</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/区块链/" style="font-size: 15px;">区块链</a> <a href="/tags/密码学/" style="font-size: 20px;">密码学</a> <a href="/tags/比特币/" style="font-size: 15px;">比特币</a> <a href="/tags/随机数/" style="font-size: 10px;">随机数</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/bitcoin-explained-with-emoji-2/">比特币的另类解释之表情包·中篇</a>
          </li>
        
          <li>
            <a href="/2017/07/bitcoin-explained-with-emoji-1/">比特币的另类解释之表情包·上篇</a>
          </li>
        
          <li>
            <a href="/2016/08/ubuntu-on-windows/">Ubuntu on Windows 初体验</a>
          </li>
        
          <li>
            <a href="/2016/06/mac-notes/">MAC使用笔记</a>
          </li>
        
          <li>
            <a href="/2016/02/sorting-algorithms/">排序算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Brighton Zhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'brightonzhang-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>